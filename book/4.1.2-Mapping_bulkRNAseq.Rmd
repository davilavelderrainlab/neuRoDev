# Mapping Bulk data{#mapping-bulk}
## Loading necessary libraries and data

### Loading the right libraries

```{r, echo=FALSE}
setwd("~/Desktop/tutorial/tutorial/inst/book")
```

```{r, message=FALSE, warning=FALSE}
# functions package
library(neuRoDev)
# extra packages
library(ComplexHeatmap)
library(gtools)
library(edgeR)
```

### Loading the networks necessary objects

```{r, eval=FALSE}
corticogenesis_sce <- corticogenesis.sce(directory = '~/Downloads')
neurogenesis_sce <- neurogenesis.sce(directory = '~/Downloads')
gliogenesis_sce <- gliogenesis.sce(directory = '~/Downloads')
```

```{r, message=FALSE, warning=FALSE, echo=F}
load("~/Downloads/corticogenesis.sce.rda")
load("~/Downloads/neurogenesis.sce.rda")
load("~/Downloads/gliogenesis.sce.rda")
```

Load preferential expression of Gene Ontology Biological Processes (BP), Molecular Functions (MF), and Cellular Components (CC). The objects are available here. Each object is a list containing preferential expression scores in one of the three reference networks in the three ontologies (BP, MF, CC). Each element of each list contains the activity (`activity`) derived from Gene Set Variation Analysis (one value per gene set in each cluster) and the preferential expression scores (`preferential`; one value per gene set in each subclass).
Further gene set enrichment values can be found in the files `corticogenesis_preferentialEnrichR`, `neurogenesis_preferentialEnrichR`, and `gliogenesis_preferentialEnrichR`.

```{r, echo=T}
# select the path in which you have saved them
corticogenesis_preferential_GO <- readRDS('~/Downloads/corticogenesis_preferential_GO.rds')
neurogenesis_preferential_GO <- readRDS('~/Downloads/neurogenesis_preferential_GO.rds')
gliogenesis_preferential_GO <- readRDS('~/Downloads/gliogenesis_preferential_GO.rds')
```

Load preferentially expressed gene list. The objects are available at: ...
```{r, echo=T}
corticogenesis_pe_genes <- readRDS("~/Downloads/corticogenesis_subclass_preferential_genes.rds")
neurogenesis_pe_genes <- readRDS("~/Downloads/neurogenesis_subclass_preferential_genes.rds")
gliogenesis_pe_genes <- readRDS("~/Downloads/gliogenesis_subclass_preferential_genes.rds")
```

Load the manually curated Gene Ontology Biological Processes for the corticogenesis and neurogenesis networks, available here.
```{r, echo=T}
corticogenesis_GO <- readRDS('~/Downloads/corticogenesis_GOBP_genesets.rds')
neurogenesis_GO <- readRDS('~/Downloads/neurogenesis_GOBP_genesets.rds')
```

## Mapping a bulk cell RNAseq dataset

This example dataset from Gordon et al. (2021) can be downloaded from: ...
This dataset contains bulk RNAseq expression of organoid samples at different time points. For the scope of the analyses, we pre-processed the data, removing batch-effect using the package `sva`, and then computed Counts Per Million (CPM) (log-normalized, saved in `logcounts`). Pre-processing steps can be done differently and depending on your own dataset characteristics, but the following steps shown in this tutorial will apply to any bulk RNAseq samples. A lack of correct pre-processing steps may affect the results and interpretation of the following analyses.

```{r, message=FALSE, eval=TRUE}
bulk_sce <- readRDS('~/Downloads/bulk_sce.rds')
```

We average between samples with the same differentiation day. If you are interested in variability between replicates, this step can be avoided.

```{r, message=FALSE, warning=FALSE}
bulk_average <- neuRoDev:::get_column_group_average(logcounts(bulk_sce), 
                                                    bulk_sce$`differentiation day`)
```

Differently than scRNAseq dataset mapping (see \@ref(4.1-Mapping_scRNAseq)), bulk RNAseq datasets don't need further processing into transcriptional profiles, as they already represent a pool of cells sequenced together. Hence, bulk samples can be directly mapped using the `mapNetwork` function, that requires the following main inputs:

 - `net`: the reference network to use
 - `new_profiles`: the transcriptomic profiles to map
 
Other useful inputs can be checked by `?mapNetwork`

```{r}
mapped_bulk <- mapNetwork(net = corticogenesis_sce, 
                          new_profiles = bulk_average)
```

We can now visualize the network with the mapped clusters on top:

```{r ch5-fig1, fig.cap="Corticogenesis network with mapped samples."}
mapped_bulk$new_plot
```

From the visualization, we can already appreciate how the samples at early days (d25, d50) map close to radial glia clusters, moving towards immature neurons in days 75, 100 and 150. 
Nevertheless, from day 200 we can see that there is a unexpected transcriptional switch and samples return to map closer to radial glia. This could mean either that they somehow went back to a more undifferentiated state, or that they start looking more like mature glia (astrocytes in particular, which are similar to radial glia, also biologically). To investigate in deep these differences, it is possible to leverage the analyses tools described below. 

Since newly mapped samples will locate close to the most similar reference clusters, it is possible to qualitatively understand the most similar subclass for each mapped point. To quantify this similarity, we developed a score per subclass per mapped sample, using the 15 most similar reference clusters' annotations (the number of reference clusters to use can be set by changing `n_nearest` in the `mapNetwork` function). The score can be visualized by:

```{r ch5-fig2, fig.height=3, fig.align='center', out.width='95%', fig.cap="Annotation scores across samples"}
mapped_bulk$annotation$Barplot
```

Days 250, 300 and 400 have a small resemblance to astrocytes, but this is lost in days 500 and 600.

To get a single label for each mapped cluster, we take the maximum of these scores. 
This depicts the most similar subclass among the closest neighbors.

```{r}
mapped_bulk$annotation$Best.Annotation
```

The same quantification can be done for stages instead of subclasses, either by specifying `color_attr = 'Stages'` in the `mapNetwork` function, or by running the `annotateMapping` function, which requires the following inputs:

 - `net`: the reference network to use.
 - `new_cor`: the correlation between mapped points and reference clusters, can be found by `mapped_object$new_cor`.
 - `color_attr`: the annotation label to use, in this case 'Stages'.
 
Our mapping strategy allows the mapping of any expression matrix, thus we added a quantification of the mapping confidence, described with two diverse measures:

  a. **local score** (`mapped_object$annotation$Mapping.Confidence`) for each mapped point, showing average of the 15 highest correlation values that mapped point has with the reference clusters.
  
  b. **global score** (`mapped_object$annotation$Global.Confidence`), describing the average confidence among all mapped point. 


The confidence values can be accessed in the following way:
 
```{r}
# global confidence
mapped_bulk$annotation$Global.Confidence

# per cluster confidence
mapped_bulk$annotation$Mapping.Confidence
```

We can see that generally the mapped samples have relatively high confidence, but it decreases in the last days compared to the first.

A further analysis is mapping the samples directly on the eTraces, to see how similar they are to clusters that express more or less certain genes. 
The function to perform such analysis is `map_eTrace`, which requires the following inputs:

 - `net`: the reference network to use.
 - `mapped_obj`: the result of `mapNetwork`.
 - the inputs required to run `plot_eTrace` (see the Chapter \@ref(analysis)).
 
```{r ch5-fig3, fig.cap="Preferential genes eTrace in corticogenesis and mapped points.", fig.show='hold', fig.align='center', out.width='50%'}
map_eTrace(net = corticogenesis_sce, 
           mapped_obj = mapped_bulk, 
           genes = corticogenesis_pe_genes$RG, 
           main = 'RG')

map_eTrace(net = corticogenesis_sce, 
           mapped_obj = mapped_bulk, 
           genes = corticogenesis_pe_genes$miEN.imNIT.eEN, 
           main = 'immEN')

map_eTrace(net = corticogenesis_sce, 
           mapped_obj = mapped_bulk, 
           genes = corticogenesis_pe_genes$L6IT.L6NIT.L35IT.L23IT.SST.VIP.PVALB.LAMP5, 
           main = 'matNEU')

map_eTrace(net = corticogenesis_sce, 
           mapped_obj = mapped_bulk, 
           genes = corticogenesis_pe_genes$Astro, 
           main = 'Astrocytes')
```
 
The eTrace of radial glia markers describes the same pattern shown when looking at the mapping on the network: the mapped points form a circle from early time points to late ones, that goes back to showing resemblance to early radial glia clusters. This further indicates that not only the look more similar to radial glia than neurons, but also that they look more similar to early radial glia compared to late ones. 
By looking instead at the eTrace of immature excitatory neuron markers, we can see that samples from d75 to d200 are above the average line (d200 being the lowest), pointing to the fact that only these time points show a similarity to immature neurons. By plotting instead the eTrace of mature neurons, no sample shows particularly high values, suggesting that organoids do not recapitulate the full maturity described by in vivo samples. Lastly, the eTrace of astrocyte markers shows that days from 250 to 400 are indeed higher than the other samples (but also late radial glia clusters show relatively high values), but clearly that days 500 and 600 are much lower.

We can additionally check the expression of preferentially expressed genes defined within our resource in the mapped samples. We show here a function to do this, which is not included in the package (to keep only the main functions). The function `plotTrends` requires the following inputs:

 - `net`: the reference network to use.
 - `pref_exp_genes`: the preferentially expressed genes list.
 - `sce`: the external object in the form of a SingleCellExperiment object,
 - `profiles`: the actual expression matrix used for the mapping.
 - `coldata`: where to find the information of the replicates used for averaging.
 - `subclass`: if indicated as a vector it selects only a subset of reference subclasses. Defaults to all subclasses.
 - `ylim`: the lower and upper limits of the y-axis (defaults to NULL, which goes back to the automatic R plot ylim).
 - `together`: defines if the different preferentially expressed genes should be plotted together (adjust `ylim` accordingly) (defaults to FALSE).
 - `relative`: if TRUE, the expression is scaled from 0 to 1 (defaults to FALSE).

<details>
<summary><strong>Show the code (`plotTrends` function)</strong></summary>
```{r}
plotTrends <- function(net, pref_exp_genes, sce, profiles, coldata, subclass = NULL, ylim = NULL, together = FALSE, relative = FALSE) {
  
  if(is.null(subclass)) {
    subclass <- unique(net$SubClass)
  }
  
  if(!together) {
    lapply(subclass, function(i) {
      g <- unlist(pref_exp_genes[names(pref_exp_genes) == i])
      g <- g[g %in% rownames(profiles)]
      if(length(g) < 2) {
        return(NULL)
      }
      
      y_means <- Matrix::colMeans(profiles[g, , drop = FALSE])
      single_values <- Matrix::colMeans(logcounts(sce)[g,])
      
      if(relative) {
        norm_factor <- max(y_means)
      } else {
        norm_factor <- 1
      }
      
      y_means <- y_means/norm_factor
      single_values <- single_values/norm_factor
      
      days <- colnames(profiles)
      y_sds <- sapply(days, function(d) {
        vals <- Matrix::colMeans(logcounts(sce)[g, colData(sce)[,coldata] == d, drop = FALSE])/norm_factor
        sd(vals)
      })
      y_sds[which(is.na(y_sds))] <- 0
      
      ylim_range <- range(c(y_means - y_sds, y_means + y_sds))
      ylim_range_two <- range(single_values)
      ylim_range <- c(min(c(ylim_range[1], ylim_range_two[1])), max(c(ylim_range[2], ylim_range_two[2])))
      if(!is.null(ylim)) {
        ylim_range <- ylim
      }
      
      plot(seq_along(y_means), y_means,
           ylab = ifelse(relative, 'relative expression', 'expression'), xlab = '', xaxt = 'n',
           type = 'l', lwd = 2,
           col = net$SubClass_color[which(net$SubClass == i)][1],
           main = i, ylim = ylim_range)
      axis(side = 1, at = seq_along(y_means), labels = days, las = 2)
      
      x_vals <- seq_along(y_means)
      upper <- y_means + y_sds
      lower <- y_means - y_sds
      polygon(c(x_vals, rev(x_vals)),
              c(upper, rev(lower)),
              col = adjustcolor(net$SubClass_color[which(net$SubClass == i)][1], alpha.f = 0.2),
              border = NA)
      
      lines(x_vals, y_means, lwd = 2,
            col = net$SubClass_color[which(net$SubClass == i)][1])
      
      for (j in seq_along(y_means)) {
        d <- names(y_means)[j]
        y_vals <- single_values[which(colData(sce)[,coldata] == d)]
        x_jitter <- jitter(rep(j, length(y_vals)), amount = 0.1)
        x_jitter[1] <- j
        show_top <- length(x_jitter)-2
        if(length(x_jitter) < 2) {
          idxs <- seq(1,length(x_jitter))
        } else {
          idxs <- c(which.min(y_vals), which.max(y_vals), sample(seq(1,length(x_jitter)), show_top)) 
        }
        x_jitter <- x_jitter[idxs]
        y_vals <- y_vals[idxs]
        points(x_jitter, y_vals, pch = 19, col = adjustcolor(net$SubClass_color[which(net$SubClass == i)][1], alpha.f = 0.5), cex = 0.5)
      }
      
    }) 
  } else {
    
    days <- colnames(profiles)
    
    all_y_means <- lapply(subclass, function(i) {
      g <- unlist(pref_exp_genes[names(pref_exp_genes) == i])
      g <- g[g %in% rownames(profiles)]
      if(length(g) < 2) {
        return(NULL)
      }
      y_means <- Matrix::colMeans(profiles[g, , drop = FALSE])
      single_values <- Matrix::colMeans(logcounts(sce)[g,])
      
      if(relative) {
        norm_factor <- max(y_means)
      } else {
        norm_factor <- 1
      }
      
      y_means <- y_means/norm_factor
      single_values <- single_values/norm_factor
      
      y_sds <- sapply(days, function(d) {
      vals <- Matrix::colMeans(logcounts(sce)[g, colData(sce)[,coldata] == d, drop = FALSE])/norm_factor
        sd(vals)
      })
      y_sds[which(is.na(y_sds))] <- 0
      return(c(y_means - y_sds, y_means + y_sds))
      
    })
    
    g <- unlist(pref_exp_genes[names(pref_exp_genes) == subclass[1]])
    g <- g[g %in% rownames(profiles)]
    if(length(g) < 2) {
      return(NULL)
    }
    
    y_means <- Matrix::colMeans(profiles[g, , drop = FALSE])
    single_values <- colMeans(logcounts(sce)[g,])
    
    if(relative) {
      norm_factor <- max(y_means)
    } else {
      norm_factor <- 1
    }
    
    y_means <- y_means/norm_factor
    single_values <- single_values/norm_factor
      
    days <- colnames(profiles)
    y_sds <- sapply(days, function(d) {
      vals <- Matrix::colMeans(logcounts(sce)[g, colData(sce)[,coldata] == d, drop = FALSE])/norm_factor
      sd(vals)
    })
    y_sds[which(is.na(y_sds))] <- 0
    
    ylim_range <- range(c(y_means - y_sds, y_means + y_sds))
    ylim_range_two <- range(single_values)
    ylim_range <- c(min(c(ylim_range[1], ylim_range_two[1])), max(c(ylim_range[2], ylim_range_two[2])))
    if(!is.null(ylim)) {
      ylim_range <- ylim
    }
    
    plot(seq_along(y_means), y_means,
         ylab = ifelse(relative, 'relative expression', 'expression'), xlab = '', xaxt = 'n',
         type = 'l', lwd = 2,
         col = net$SubClass_color[which(net$SubClass == subclass[1])][1],
         main = paste0(subclass, collapse = '-'), ylim = ylim_range)
    axis(side = 1, at = seq_along(y_means), labels = days, las = 2)
    
    x_vals <- seq_along(y_means)
    upper <- y_means + y_sds
    lower <- y_means - y_sds
    polygon(c(x_vals, rev(x_vals)),
            c(upper, rev(lower)),
            col = adjustcolor(net$SubClass_color[which(net$SubClass == subclass[1])][1], alpha.f = 0.2),
            border = NA)
    
    lines(x_vals, y_means, lwd = 2,
          col = net$SubClass_color[which(net$SubClass == subclass[1])][1])
    
    for (j in seq_along(y_means)) {
      d <- names(y_means)[j]
      y_vals <- single_values[which(colData(sce)[,coldata] == d)]
      x_jitter <- jitter(rep(j, length(y_vals)), amount = 0.1)
      x_jitter[1] <- j
      show_top <- length(x_jitter)-2
      if(length(x_jitter) < 2) {
        idxs <- seq(1,length(x_jitter))
      } else {
        idxs <- c(which.min(y_vals), which.max(y_vals), sample(seq(1,length(x_jitter)), show_top)) 
      }
      x_jitter <- x_jitter[idxs]
      y_vals <- y_vals[idxs]
      points(x_jitter, y_vals, pch = 19, col = adjustcolor(net$SubClass_color[which(net$SubClass == subclass[1])][1], alpha.f = 0.5), cex = 0.5)
    }
    
    for(i in subclass[seq(2,length(subclass))]) {
      g <- unlist(pref_exp_genes[names(pref_exp_genes) == i])
      g <- g[g %in% rownames(profiles)]
      if(length(g) < 2) {
        return(NULL)
      }
      
      y_means <- Matrix::colMeans(profiles[g, , drop = FALSE])
      single_values <- Matrix::colMeans(logcounts(sce)[g,])
      
      if(relative) {
        norm_factor <- max(y_means)
      } else {
        norm_factor <- 1
      }
      
      y_means <- y_means/norm_factor
      single_values <- single_values/norm_factor
      
      days <- colnames(profiles)
      y_sds <- sapply(days, function(d) {
        vals <- Matrix::colMeans(logcounts(sce)[g, colData(sce)[,coldata] == d, drop = FALSE])/norm_factor
        sd(vals)
      })
      y_sds[which(is.na(y_sds))] <- 0
      
      ylim_range <- range(c(y_means - y_sds, y_means + y_sds))
      ylim_range_two <- range(single_values)
      ylim_range <- c(min(c(ylim_range[1], ylim_range_two[1])), max(c(ylim_range[2], ylim_range_two[2])))
      if(!is.null(ylim)) {
        ylim_range <- ylim
      }
      
      lines(y_means,
           lwd = 2,
           col = net$SubClass_color[which(net$SubClass == i)][1])
      
      x_vals <- seq_along(y_means)
      upper <- y_means + y_sds
      lower <- y_means - y_sds
      polygon(c(x_vals, rev(x_vals)),
              c(upper, rev(lower)),
              col = adjustcolor(net$SubClass_color[which(net$SubClass == i)][1], alpha.f = 0.2),
              border = NA)
      
      lines(x_vals, y_means, lwd = 2,
            col = net$SubClass_color[which(net$SubClass == i)][1])
      
      for (j in seq_along(y_means)) {
        d <- names(y_means)[j]
        y_vals <- single_values[which(colData(sce)[,coldata] == d)]
        x_jitter <- jitter(rep(j, length(y_vals)), amount = 0.1)
        x_jitter[1] <- j
        show_top <- length(x_jitter)-2
        if(length(x_jitter) < 2) {
          idxs <- seq(1,length(x_jitter))
        } else {
          idxs <- c(which.min(y_vals), which.max(y_vals), sample(seq(1,length(x_jitter)), show_top)) 
        }
        x_jitter <- x_jitter[idxs]
        y_vals <- y_vals[idxs]
        points(x_jitter, y_vals, pch = 19, col = adjustcolor(net$SubClass_color[which(net$SubClass == i)][1], alpha.f = 0.5), cex = 0.5)
      }
    }
    
  }
}
```
</details>

```{r ch5-fig4, fig.cap="Preferential genes of astrocytes and cycling radial glia expression in mapped data points.", out.width='95%', fig.align='center'}
plotTrends(net = corticogenesis_sce, 
           pref_exp_genes = corticogenesis_pe_genes, 
           subclass = c('Astro', 'cRG'), 
           sce = bulk_sce, 
           profiles = bulk_average, 
           coldata = 'differentiation day', 
           together = TRUE, 
           ylim = c(2.5, 5.5))
```

Astrocyte markers increase up to day 400, but then decrease again and are overcome by cycling radial glia markers at time points (d500, d600).

This is consistent with the expression levels of GO processes manually curated in our compendium.

To assess the expression levels of these processes, we first have to obtain the average expression of those gene sets in the mapped data:

```{r}
bulk_cortico_GOBP <- do.call(rbind, lapply(corticogenesis_GO, function(g) {
  
  g <- g[which(g %in% rownames(bulk_sce))]
  
  Matrix::colMeans(bulk_average[g,])
  
}))

rownames(bulk_cortico_GOBP) <- gsub(" \\(GO:[0-9]+\\)$", "", rownames(bulk_cortico_GOBP))
bulk_cortico_GOBP <- bulk_cortico_GOBP[,mixedorder(colnames(bulk_cortico_GOBP))]
```

Then, we can visualize the relative expression in an heatmap.
<details>
<summary><strong>Show the code (simplifying labels)</strong></summary>
```{r}
cortico_subclass_groups <- colnames(corticogenesis_preferential_GO$GO_Biological_Process_2025$preferential)
cortico_subclass_groups[which(cortico_subclass_groups %in% c('L23IT', 'L35IT', 'L6IT', 'L6NIT'))] <- 'matEN'
cortico_subclass_groups[which(cortico_subclass_groups %in% c('LAMP5', 'SST', 'PVALB', 'VIP'))] <- 'matIN'
cortico_subclass_groups[which(cortico_subclass_groups %in% c('imIT', 'imNIT', 'eEN', 'miEN'))] <- 'immEN'
cortico_subclass_groups[which(cortico_subclass_groups %in% c('eIN', 'imIN'))] <- 'immIN'
cortico_subclass_groups[which(cortico_subclass_groups %in% c('Opc', 'Oligo', 'Astro'))] <- 'maGlia'
cortico_subclass_groups[which(cortico_subclass_groups %in% c('Micro'))] <- 'miGlia'
cortico_subclass_groups[which(cortico_subclass_groups %in% c('RG', 'cRG', 'IPC'))] <- 'Prog'

cortico_subclass_groups <- factor(cortico_subclass_groups, levels = c('Prog', 'immEN', 'immIN', 'matEN', 'matIN', 'maGlia', 'miGlia'))

cortico_gobp_groups <- factor(c(rep('Astro', 4), rep('Oligo', 3), rep('Opc', 3), rep('OligoGlia', 2), rep('matEN', 4), rep('matIN', 4), rep('immEN', 4), rep('Micro', 4), rep('Prog', 4), rep('Stress', 4)), levels = c('Prog', 'immEN', 'matEN', 'matIN', 'Opc', 'Oligo', 'OligoGlia', 'Astro', 'Micro', 'Stress'))

cortico_gobp_pe <- corticogenesis_preferential_GO$GO_Biological_Process_2025$preferential[names(corticogenesis_GO),]
rownames(cortico_gobp_pe) <- gsub(" \\(GO:[0-9]+\\)$", "", rownames(cortico_gobp_pe))
```
</details>

<details>
<summary><strong>Show the code (plotting heatmap)</strong></summary>
```{r, eval=FALSE}
ht1 <- Heatmap(
  cortico_gobp_pe,
  name = 'preferential\nexpression',
  width = unit(ncol(cortico_gobp_pe) * 4.2, 'mm'),
  height = unit(nrow(cortico_gobp_pe) * 4.2, 'mm'),
  show_row_dend = FALSE,
  show_column_dend = FALSE,
  row_title_rot = 0,
  column_title_rot = 90,
  column_split = cortico_subclass_groups,
  cluster_column_slices = FALSE,
  row_split = cortico_gobp_groups,
  cluster_row_slices = FALSE,
  column_title_gp = gpar(fontsize = 0)
)

ht2 <- Heatmap(
  t(scale(t(bulk_cortico_GOBP))),
  name = 'scaled\nexpression',
  width = unit(ncol(bulk_cortico_GOBP) * 4.2, 'mm'),
  cluster_columns = FALSE, right_annotation = rowAnnotation(max = anno_barplot(apply(bulk_cortico_GOBP, 1, max), gp = gpar(fill = 'black')), annotation_name_side = 'top', annotation_name_rot = 0)
)

ht_list <- ht1 + ht2

draw(ht_list, heatmap_legend_side = "left")
```
</details>

```{r, echo=FALSE}
ht1 <- Heatmap(
  cortico_gobp_pe,
  name = 'preferential\nexpression',
  width = unit(ncol(cortico_gobp_pe) * 4.2, 'mm'),
  height = unit(nrow(cortico_gobp_pe) * 4.2, 'mm'),
  show_row_dend = FALSE,
  show_column_dend = FALSE,
  row_title_rot = 0,
  column_title_rot = 90,
  column_split = cortico_subclass_groups,
  cluster_column_slices = FALSE,
  row_split = cortico_gobp_groups,
  cluster_row_slices = FALSE,
  column_title_gp = gpar(fontsize = 0)
)

ht2 <- Heatmap(
  t(scale(t(bulk_cortico_GOBP))),
  name = 'scaled\nexpression',
  width = unit(ncol(bulk_cortico_GOBP) * 4.2, 'mm'),
  cluster_columns = FALSE, right_annotation = rowAnnotation(max = anno_barplot(apply(bulk_cortico_GOBP, 1, max), gp = gpar(fill = 'black')), annotation_name_side = 'top', annotation_name_rot = 0)
)

ht_list <- ht1 + ht2
```


```{r ch5-fig5, echo=FALSE, fig.cap="Heatmap of corticogenesis-specific GO biological processes in resource and mapped samples.", out.width='98%', fig.align='left', fig.width=14, fig.height=8}
draw(ht_list, 
     heatmap_legend_side = "left",
     padding = unit(c(5, 1, 2, 90), "mm"))
```


From this heatmap we can see that radial glia biological processes are highly expressed in the first 2-3 time points, but also in the last two. This, together with a high expression of stress-related processes (which increases as time progresses) suggests that indeed the last days are more stressed rather than being more similar to astrocytes. Also neuronal processes start around day 75, but decrease around days 300-400.

The same type of analysis can be done with the neurogenesis network:

```{r}
bulk_neuro_GOBP <- do.call(rbind, lapply(neurogenesis_GO, function(g) {
  
  g <- g[which(g %in% rownames(bulk_average))]
  
  Matrix::colMeans(bulk_average[g,])
  
}))

rownames(bulk_neuro_GOBP) <- gsub(" \\(GO:[0-9]+\\)$", "", rownames(bulk_neuro_GOBP))
bulk_neuro_GOBP <- bulk_neuro_GOBP[,mixedorder(colnames(bulk_neuro_GOBP))]
```

<details>
<summary><strong>Show the code (simplifying labels and plotting heatmap)</strong></summary>
```{r, eval=F}
neuro_gobp_pe <- neurogenesis_preferential_GO$GO_Biological_Process_2025$activity[names(neurogenesis_GO),]

neuroTrends <- do.call(cbind, lapply(rownames(neuro_gobp_pe), function(i) smooth.spline(1:length(neuro_gobp_pe[i,]), neuro_gobp_pe[i,], spar = 1)$y))
colnames(neuroTrends) <- rownames(neuro_gobp_pe)

neuroTrends <- t(neuroTrends)[names(neurogenesis_GO),]
neuroTrends <- neuroTrends[order(apply(neuroTrends, 1, which.max), Matrix::rowMeans(neuroTrends)),]

rownames(neuroTrends) <- gsub(" \\(GO:[0-9]+\\)$", "", rownames(neuroTrends))

stage_palette <- unique(neurogenesis_sce$Stages_color)
names(stage_palette) <- unique(neurogenesis_sce$Stages)

h1 <- Heatmap(t(scale(t(neuroTrends))), 
              cluster_columns = F, 
              cluster_rows = F, 
              bottom_annotation = HeatmapAnnotation(df=data.frame(stage=neurogenesis_sce$Stages), 
                                                    col=list(stage=stage_palette), 
                                                    show_legend = F, 
                                                    show_annotation_name = F), 
              name = 'inferred expression\n(z scaled)', 
              height = unit(100, 'mm'), 
              width = unit(30, 'mm'), 
              row_names_max_width = unit(20, "mm"))

ht2 <- Heatmap(
  t(scale(t(bulk_neuro_GOBP[rownames(neuroTrends),]))),
  name = 'scaled\nexpression',
  width = unit(ncol(bulk_neuro_GOBP) * 4.2, 'mm'),
  cluster_columns = FALSE, right_annotation = rowAnnotation(max = anno_barplot(apply(bulk_neuro_GOBP[rownames(neuroTrends),], 1, max), gp = gpar(fill = 'black'))), , row_names_max_width = unit(20, "mm")
)

ht_list <- h1 + ht2
draw(ht_list, 
     heatmap_legend_side = "left")
```
</details>

```{r, echo=FALSE}
neuro_gobp_pe <- neurogenesis_preferential_GO$GO_Biological_Process_2025$activity[names(neurogenesis_GO),]

neuroTrends <- do.call(cbind, lapply(rownames(neuro_gobp_pe), function(i) smooth.spline(1:length(neuro_gobp_pe[i,]), neuro_gobp_pe[i,], spar = 1)$y))
colnames(neuroTrends) <- rownames(neuro_gobp_pe)

neuroTrends <- t(neuroTrends)[names(neurogenesis_GO),]
neuroTrends <- neuroTrends[order(apply(neuroTrends, 1, which.max), Matrix::rowMeans(neuroTrends)),]

rownames(neuroTrends) <- gsub(" \\(GO:[0-9]+\\)$", "", rownames(neuroTrends))

stage_palette <- unique(neurogenesis_sce$Stages_color)
names(stage_palette) <- unique(neurogenesis_sce$Stages)

h1 <- Heatmap(t(scale(t(neuroTrends))), 
              cluster_columns = F, 
              cluster_rows = F, 
              bottom_annotation = HeatmapAnnotation(df=data.frame(stage=neurogenesis_sce$Stages), 
                                                    col=list(stage=stage_palette), 
                                                    show_legend = F, 
                                                    show_annotation_name = F), 
              name = 'inferred expression\n(z scaled)', 
              height = unit(100, 'mm'), 
              width = unit(30, 'mm'), 
              row_names_gp = gpar(fontsize=10))

ht2 <- Heatmap(
  t(scale(t(bulk_neuro_GOBP[rownames(neuroTrends),]))),
  name = 'scaled\nexpression',
  width = unit(ncol(bulk_neuro_GOBP) * 4.2, 'mm'),
  cluster_columns = FALSE, 
  right_annotation = rowAnnotation(max = anno_barplot(apply(bulk_neuro_GOBP[rownames(neuroTrends),], 1, max), gp = gpar(fill = 'black'))), 
  row_names_gp = gpar(fontsize=10),
  row_names_max_width = max_text_width(
        rownames(t(bulk_neuro_GOBP[rownames(neuroTrends),])), 
        gp = gpar(fontsize = 7)
    )
)

ht_list <- h1 + ht2
```

```{r ch5-fig6, echo=FALSE, fig.cap="Heatmap of neuroogenesis-specific GO biological processes in resource and mapped samples.", out.width='90%',fig.width=10}

draw(ht_list, 
     heatmap_legend_side = "left",
     padding = unit(c(5, 1, 2, 90), "mm"))
```

We can see that neuroinflammatory response regulation increases over time, as well as regulation of neuron apoptotic process. 

Another approach to confirm our findings is to obtain markers for each cluster using the Seurat function `FindAllMarkers` and plot those genes in the eTraces.

```{r}
dge_obj <- DGEList(counts=counts(bulk_sce), 
                   samples=cbind(colData(bulk_sce), 
                                 bulk_sce$`differentiation day`))

keep <- filterByExpr(dge_obj, 
                     group=bulk_sce$`differentiation day`)

dge_obj <- dge_obj[keep, , keep.lib.sizes=FALSE]

dge_obj <- calcNormFactors(dge_obj)
```

<details>
<summary><strong>Show the code (differential expression)</strong></summary>
```{r}
unique_groups <- unique(bulk_sce$`differentiation day`)
de_list <- list()

for (g in unique_groups) {
  binary_group <- ifelse(bulk_sce$`differentiation day` == g, g, paste0("Not", g))
  binary_group <- factor(binary_group)
  
  sample_info <- data.frame('binary_group' = binary_group, 
                            'groups' = bulk_sce$`differentiation day`)
  
  design <- stats::model.matrix(~ binary_group, data=sample_info)
  
  dge_obj <- estimateDisp(dge_obj, 
                          design)
  
  fit <- glmQLFit(dge_obj, 
                  design)
  
  qlf <- glmQLFTest(fit, 
                    coef=2)
  
  res <- topTags(qlf, 
                 n=Inf)
  
  res <- res$table[which(res$table$FDR < 0.05),]
  
  if(all(sign(res$logFC) == sign(res$logFC)[1])) {
    de_list[[g]] <- res
    next()
  }
  
  v1 <- Matrix::colMeans(bulk_average[rownames(res)[which(res$logFC > 0)],])
  v2 <- Matrix::colMeans(bulk_average[rownames(res)[which(res$logFC < 0)],])
  
  if(rank(v1)[g] > rank(v2)[g]) {
    res <- res[which(res$logFC > 0),]  
  } else {
    res <- res[which(res$logFC < 0),]
  }
  
  de_list[[g]] <- res
}
```
</details>

We order the genes based on the (-log10) FDR keeping those that are also present in the corticogenesis resource.
<details>
<summary><strong>Show the code (filtering genes)</strong></summary>
```{r}
de_list <- lapply(de_list, function(i) {
  i$score <- -log10(i$FDR)
  i <- i[order(i$score, decreasing = T),]
  return(i)
  }
)

markers <- lapply(de_list, function(i) {
  rownames(i)
  }
)

markers <- lapply(markers, function(i) {
  i[which(i %in% rownames(corticogenesis_sce))]
  }
)

markers <- markers[which(unlist(lapply(markers, length)) > 0)]
```
</details>

```{r, eval=F, echo=T}
for(i in names(markers)) {
  g <- markers[[i]]
  g <- g[which(g %in% rownames(corticogenesis_sce))]
  plot_eTrace(net = corticogenesis_sce, genes = g, main = i)
}
```

```{r ch5-fig7, message=FALSE, warning=FALSE, fig.show='hold', fig.align='left', out.width='48%', eval=T, echo=FALSE, fig.cap="eTrace of sample-specific differential genes in corticogenesis."}
plot_eTrace(net = corticogenesis_sce, 
            genes = markers[[1]], 
            main = paste("markers of day",names(markers)[[1]]))
plot_eTrace(net = corticogenesis_sce, 
            genes = markers[[2]], 
            main = paste("markers of day",names(markers)[[2]]))
plot_eTrace(net = corticogenesis_sce, 
            genes = markers[[3]], 
            main = paste("markers of day",names(markers)[[3]]))
plot_eTrace(net = corticogenesis_sce, 
            genes = markers[[4]], 
            main = paste("markers of day",names(markers)[[4]]))
plot_eTrace(net = corticogenesis_sce, 
            genes = markers[[5]], 
            main = paste("markers of day",names(markers)[[5]]))
plot_eTrace(net = corticogenesis_sce, 
            genes = markers[[6]], 
            main = paste("markers of day",names(markers)[[6]]))
plot_eTrace(net = corticogenesis_sce, 
            genes = markers[[7]], 
            main = paste("markers of cluster",names(markers)[[7]]))
plot_eTrace(net = corticogenesis_sce, 
            genes = markers[[8]], 
            main = paste("markers of cluster",names(markers)[[8]]))
plot_eTrace(net = corticogenesis_sce, 
            genes = markers[[9]], 
            main = paste("markers of cluster",names(markers)[[9]]))
plot_eTrace(net = corticogenesis_sce, 
            genes = markers[[10]], 
            main = paste("markers of cluster",names(markers)[[10]]))
```


From this analysis we can appreciate how genes differentially expressed in the different samples are expressed in our reference. We can appreciate how genes differentially expressed in organoids from the early time points decrease their expression over time, particularly those of day 25. 
From day 75 to day 200 we notice that the differentially expressed genes are mainly neuronal, and in particular for day 200, and they are highly expressed in immature neurons, decreasing along maturation. Interestingly, differentially expressed genes in days 300 and 400 are indeed more expressed by astrocytes and increase over time, while those specific for day 600 are higher in radial glia cells and microglia, which usually hints to a stress response (! microglia shouldn't populate these organoids).
