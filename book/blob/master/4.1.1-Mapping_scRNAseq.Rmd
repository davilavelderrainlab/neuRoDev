# Mapping Single-cell data{#mapping-sc}
## Loading necessary libraries and data

### Loading the right libraries

```{r, echo=FALSE}
setwd("~/Desktop/tutorial/tutorial/inst/book")
```

```{r, warning =F, message=F}
# functions package
library(neuRoDev)
# extra packages
library(readxl)
library(Seurat)
library(ComplexHeatmap)
library(gtools)
library(ggplot2)
library(viridis)
library(Matrix)
library(SingleCellExperiment)
```

### Loading the networks necessary objects

```{r}
load("~/Downloads/corticogenesis.sce.rda")
load("~/Downloads/neurogenesis.sce.rda")
load("~/Downloads/gliogenesis.sce.rda")
```


Load preferential expression of Gene Ontology Biological Processes (BP), Molecular Functions (MF), and Cellular Components (CC). The objects are available here. Each object is a list containing preferential expression scores in one of the three reference networks in the three ontologies (BP, MF, CC). Each element of each list contains the activity (`activity`) derived from Gene Set Variation Analysis (one value per gene set in each cluster) and the preferential expression scores (`preferential`; one value per gene set in each subclass).
Further gene set enrichment values can be found in the files `corticogenesis_preferentialEnrichR`, `neurogenesis_preferentialEnrichR`, and `gliogenesis_preferentialEnrichR`.

```{r}
# select the path in which you have saved the objects!
corticogenesis_preferential_GO <- readRDS('~/Downloads/corticogenesis_preferential_GO.rds')
neurogenesis_preferential_GO <- readRDS('~/Downloads/neurogenesis_preferential_GO.rds')
gliogenesis_preferential_GO <- readRDS('~/Downloads/gliogenesis_preferential_GO.rds')
```

Load preferentially expressed gene list. The objects are available at: ...

```{r}
corticogenesis_pe_genes <- read_excel("~/Downloads/preferentially_expressed_gene_list.xlsx", sheet = "corticogenesis")
neurogenesis_pe_genes <- read_excel("~/Downloads/preferentially_expressed_gene_list.xlsx", sheet = "neurogenesis")
gliogenesis_pe_genes <- read_excel("~/Downloads/preferentially_expressed_gene_list.xlsx", sheet = "gliogenesis")

#removing NA
corticogenesis_pe_genes <- apply(corticogenesis_pe_genes, 2, function(i) {i[which(!is.na(i))]}) 
neurogenesis_pe_genes <- apply(neurogenesis_pe_genes, 2, function(i) {i[which(!is.na(i))]})
gliogenesis_pe_genes <- apply(gliogenesis_pe_genes, 2, function(i) {i[which(!is.na(i))]})
```

Load the manually curated Gene Ontology Biological Processes for the corticogenesis and neurogenesis networks, available at: ...
These gene sets were manually curated to represent essential pathways in the processes of corticogenesis, neurogenesis, and gliogenesis.

```{r}
corticogenesis_GO <- readRDS('~/Downloads/corticogenesis_GOBP_genesets.rds')
neurogenesis_GO <- readRDS('~/Downloads/neurogenesis_GOBP_genesets.rds')
```

## Mapping a single cell RNAseq dataset

### Data preprocessing

This example dataset from Kanton et al. (2019) (10.1038/s41586-019-1654-9) can be downloaded from: ...
For the scope of the analyses, we pre-processed the data, removing low quality cells. We also performed proportional random sampling to ease following this tutorial, to a total of 10.000 cells. This implies the reduction of total cell number while keeping cell groups proportions. 
To reproduce the figures in the paper, we used the complete dataset, processed using the `ACTIONet` pipeline up to clustering (see: https://compbio.mit.edu/ACTIONet/tutorials/intro.html. The data were processed by using the following functions with default parameters: `normalize.ace`, `reduce.ace`, `runACTIONet`, `clusterCells`).

Note: quality control needs to be done specifically to your dataset. We assume that cells in the following steps have passed standard quality controls. You can refer to the Seurat pipeline here: https://satijalab.org/seurat/archive/v3.0/pbmc3k_tutorial.html or to the scanpy one in Python: https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html.

```{r, message=FALSE, eval=FALSE}
ext_count_matrix <- readRDS('~/Downloads/sc_count_matrix.rds')
```

Here we report the detailed pipeline of the standard Seurat steps required to obtain clusters, which are needed for the following analyses. It is possible to customize some parameters for the pipeline, which have to be tuned to your specific dataset.

<details>
<summary><strong>Show code</strong></summary>
```{r, echo = T, eval=F}
# The pre-processing steps are done following the standard Seurat pipeline:
library(Seurat)

sc_seu <- CreateSeuratObject(counts = ext_count_matrix)
sc_seu <- NormalizeData(object = sc_seu)
sc_seu <- FindVariableFeatures(object = sc_seu, span = 0.3)
sc_seu <- ScaleData(object = sc_seu, features = VariableFeatures(sc_seu))
numPCs <- min(50, ncol(ext_count_matrix) - 1)
sc_seu <- RunPCA(object = sc_seu, features = VariableFeatures(sc_seu), npcs = numPCs, approx = FALSE)

PCs_to_use <- (sc_seu$pca@stdev)^2
PCs_to_use <- PCs_to_use/sum(PCs_to_use)
PCs_to_use <- cumsum(PCs_to_use)
PCs_to_use <- min(which(PCs_to_use >= 0.75))

PCs_to_use <- min(numPCs, PCs_to_use)

sc_seu <- FindNeighbors(object = sc_seu, dims = seq_len(PCs_to_use))
sc_seu <- FindClusters(object = sc_seu, resolution = 1, algorithm = 4, random.seed = 1) # if this gives an error, try setting algorithm to 1 or check ?FindClusters

sc_seu <- RunUMAP(sc_seu, dims = seq_len(PCs_to_use))
```
</details>

```{r, eval=TRUE, echo=FALSE}
sc_seu <- readRDS('~/Downloads/sc_seurat_object.rds')
```

We can then visualize the UMAP with the clusters:

```{r ch4-fig1, fig.cap="Single-cell dataset UMAP with clusters."}
DimPlot(sc_seu, 
        reduction = "umap", 
        label = TRUE)
```

Since this dataset contains cells from different stages, we can also check the stages distribution and map this information on the single cells:

```{r ch4-fig2, fig.cap="Single-cell dataset UMAP colored by stage."}
stage_annotation <- unlist(lapply(strsplit(colnames(sc_seu), '.', fixed = TRUE), function(i) {i[2]}))
names(stage_annotation) <- Cells(sc_seu)

sc_seu$stage <- stage_annotation

stages_palette <- viridis(n = length(unique(stage_annotation)))
names(stages_palette) <- unique(stage_annotation)

DimPlot(
  sc_seu, 
  group.by = "stage",
  reduction = "umap",
  cols = stages_palette
)
```

### Data summary

The standard mapping procedure requires the definition of summary transcriptional profiles for each cluster, that can be obtained in two ways:

  1. Pseudobulk profiles (obtained by summing all counts in a cluster together and then normalizing using Counts Per Million (CPM)).
  2. Expression signatures (obtained by averaging the normalized counts of all cells in a cluster and then subtracting the mean expression across all cells).
  
Depending on the type of question, the user can choose the most suitable summary profile. The key distinction lies in the type of information captured: **signatures** represent relative expression, describing how a given cluster differs from the others and thus highlighting **differences**. In contrast, **pseudobulk profiles** capture **absolute** expression levels and are therefore more suitable for biological interpretation without emphasizing relative changes. Signatures are not suited if used in a relatively homogeneous dataset, as they will greatly enhance subtle differences which may just depicts noise. 
For the following example we will use pseudobulk profiles, which is the more straightforward approach.

Pseudobulk profiles can be computed using the following function, which will save as a `SingleCellExperiment` object the pseudobulk counts in `counts` and the log-normalized counts per millions in `logcounts`:

```{r}
get_pseudobulk <- function(exp_matrix, membership_vector) { #the membership vector represents the group by which we want to compute pseudobulk, in our case cluster labels
  unique_mv <- sort(names(which(table(membership_vector)>1))) 
  pseudo_counts <- t(DelayedArray::rowsum(t(exp_matrix), membership_vector))
  rownames(pseudo_counts) <- rownames(exp_matrix)
  norm_counts <- log2((t(t(pseudo_counts)/Matrix::colSums(pseudo_counts, na.rm = T))*1000000) + 1) #cpm normalization
  
  out <- SingleCellExperiment::SingleCellExperiment(assays=list(counts=pseudo_counts, 
                                                                logcounts=norm_counts))
  if(is.null(colnames(out))) {
    colnames(out) <- colnames(pseudo_counts)
    }
  out@metadata$cell_count <- table(membership_vector)
  return(out)

}
```

We now define the pseudobulks of the clusters that we obtained following the Seurat pipeline:

```{r, message=FALSE, warning=F}
sc_pseudo <- get_pseudobulk(exp_matrix = sc_seu@assays$RNA$counts, 
                            membership_vector = sc_seu$seurat_clusters)
colnames(sc_pseudo) <- paste0('c', colnames(sc_pseudo)) #to have strings and not numbers
```


### Mapping on the reference network

Now comes the actual mapping part, which can be easily performed using the `mapNetwork` function, that requires the following main inputs:

 - `net`: the reference network to use
 - `new_profiles`: the transcriptional profiles to map (either pseudobulk or signatures)
 
Other useful inputs can be checked in the function help (`?mapNetwork`).

Since in the original paper they mention the presence of glial cell types, inhibitory and excitatory neurons, it is reasonable to map on the corticogenesis network. If your experimental design already defines the presence of only glial cells or only excitatory neurons (with their respective precursors), then it is suggested to map only on the neurogenesis and gliogenesis steps. 
Another approach is to first map on the on the more general corticogenesis network and then map again on the precise lineage-specific networks, also on a subset of cells.

```{r}
mapped_sc_pseudo <- mapNetwork(net = corticogenesis_sce, 
                               new_profiles = logcounts(sc_pseudo))
```

We can now visualize the network with the mapped clusters on top:

```{r ch4-fig3, fig.cap="Corticogenesis network with mapped clusters."}
mapped_sc_pseudo$new_plot
```

Newly mapped clusters will locate close to the most similar reference clusters, so it is possible to observe the most similar subclasses for each mapped cluster.
By visualizing the mapped network, we can already appreciate how the clusters generally map into two different sections of the network, one close to radial glia and cycling radial glia, while the other close to immature neurons. To quantify similarity, we developed a score per subclass per cluster, using the 15 most similar reference clusters' annotations (the number of reference clusters to use can be set by changing `n_nearest` in the `mapNetwork` function). 
This score sums up to 1 and represents the weighted fraction of clusters in the neighborhood belonging to the different subclasses. 
The score can be visualized with a barplot reporting on the y-axis the proportions (between 0-1) of the different subclasses, and on the x-axis the mapped clusters.

```{r ch4-fig4, fig.cap="Annotation scores across clusters.", fig.height=3, fig.align='center'}
mapped_sc_pseudo$annotation$Barplot
```

To get a single label for each mapped cluster, we take the maximum of these scores. This depicts the most similar subclass among the closest neighbors.

```{r}
mapped_sc_pseudo$annotation$Best.Annotation
```

The same quantification can be obtained for stages of maturation, either by specifying `color_attr = 'Stages'` in the `mapNetwork` function, or by running the `annotateMapping` function, which requires the following inputs:

  - `net`: the reference network to use.
  - `new_cor`: the correlation between mapped points and reference clusters, can be found here `mapped_object$new_cor`.
  - `color_attr`: the annotation label to use, in this case 'Stages'.

Our mapping strategy allows the mapping of any expression matrix, thus we added a quantification of the mapping confidence, described with two diverse measures:

  a. **local score** (`mapped_object$annotation$Mapping.Confidence`) for each mapped point, showing average of the 15 highest correlation values that mapped point has with the reference clusters.
  
  b. **global score** (`mapped_object$annotation$Global.Confidence`), describing the average confidence among all mapped point. 

The confidence values can be accessed in the following way:
 
```{r}
# per cluster confidence
mapped_sc_pseudo$annotation$Mapping.Confidence

# global confidence
mapped_sc_pseudo$annotation$Global.Confidence
```
The confidence score not only tells how similar are the mapped points to neighboring clusters, but also can help identifying profiles of low quality or cell types not represented in the resource.

For example, cluster 23 has a slightly lower confidence score (~0.50) compared to the others, so it may be worth further checking the quality of the cells in that cluster (**not done here**), to assess whether this could be a low quality group of cells.

Sometimes clusters have a high confidence score, but nieghbors with different annotations, making it hard to actually infer a single annotation. To help with this, it is possible to apply the confidence score to the inferred annotations defined above:

```{r}
# checking the annotation confidence of the first five clusters 
mapped_sc_pseudo$annotation$Annotations.Confidence[seq(1,5)]
```

### Knwoledge transfer

The annotations newly defined can now be transferred to the original dataset and visualized at the single cell level.

```{r ch4-fig5, fig.cap="Single-cell dataset UMAP with clusters and annotations.", fig.show='hold',fig.align='center', out.width = '50%'}
new_annotation <- mapped_sc_pseudo$annotation$Best.Annotation[paste0('c', sc_seu$seurat_clusters)]
names(new_annotation) <- Cells(sc_seu)

sc_seu$annotation <- new_annotation

corticogenesis_palette <- unique(corticogenesis_sce$SubClass_color)
names(corticogenesis_palette) <- unique(corticogenesis_sce$SubClass)


DimPlot(
  sc_seu, 
  reduction = "umap",
  label = TRUE, 
) + 
  ggtitle("clusters") +
  theme(plot.title = element_text(hjust = 0.5))

DimPlot(
  sc_seu, 
  group.by = "annotation",
  reduction = "umap",
  cols = corticogenesis_palette,
) + 
  ggtitle("annotation") +
  theme(plot.title = element_text(hjust = 0.5))
```

By looking at the UMAP labelled by cluster together with the newly annotated UMAP, we can appreciate that the cells annotated as cRG close to all the cells annotated as RG are indeed those of the cluster 4, the cluster with similar annotation values for both cRG and RG.

To further validate the annotation, we can also visualize the preferentially expressed genes in the relevant subclasses:

```{r, message=F, warning=F}
sc_seu$eIN.Score <- Matrix::colMeans(
  GetAssayData(sc_seu, slot = "data")[corticogenesis_pe_genes$eIN[which(corticogenesis_pe_genes$eIN %in% rownames(sc_seu))],])


sc_seu$cRG.Score <- Matrix::colMeans(
  GetAssayData(sc_seu, slot = "data")[corticogenesis_pe_genes$cRG[which(corticogenesis_pe_genes$cRG %in% rownames(sc_seu))],])


sc_seu$RG.Score <- Matrix::colMeans(
  GetAssayData(sc_seu, slot = "data")[corticogenesis_pe_genes$RG[which(corticogenesis_pe_genes$RG %in% rownames(sc_seu))],])


sc_seu$imNIT.Score <- Matrix::colMeans(
  GetAssayData(sc_seu, slot = "data")[corticogenesis_pe_genes$imNIT[which(corticogenesis_pe_genes$imNIT %in% rownames(sc_seu))],])


sc_seu$miEN.Score <- Matrix::colMeans(
  GetAssayData(sc_seu, slot = "data")[corticogenesis_pe_genes$miEN[which(corticogenesis_pe_genes$miEN %in% rownames(sc_seu))],])

```

```{r ch4-fig6, message=F, warning=F, fig.cap="Preferential genes expression", fig.show='hold',fig.align='center', out.width = '50%'}
FeaturePlot(sc_seu, 
            features = "eIN.Score", 
            reduction = "umap") + ggtitle("eIN")
FeaturePlot(sc_seu, 
            features = "cRG.Score", 
            reduction = "umap") + ggtitle("cRG")
FeaturePlot(sc_seu, 
            features = "RG.Score", 
            reduction = "umap") + ggtitle("RG")
FeaturePlot(sc_seu, 
            features = "imNIT.Score", 
            reduction = "umap") + ggtitle("imNIT")
FeaturePlot(sc_seu, 
            features = "miEN.Score", 
            reduction = "umap") + ggtitle("miEN")
DimPlot(
  sc_seu, 
  reduction = "umap",
  group.by = "annotation",
  cols = corticogenesis_palette,
  label = TRUE, 
) + 
  ggtitle("annotation") +
  theme(plot.title = element_text(hjust = 0.5))
```

By the expression of preferentially expressed genes defined in our resource match the expectations, and that cluster 4 has high expression of cRG markers, confirming the annotations given by the mapping strategy.
To further characterize our clusters, we can leverage the list of our manually curate Gene Ontology Biological Processes and assess their expression levels.
First, we compute the average expression of those gene sets:

```{r}
sc_seu_cortico_GOBP <- do.call(rbind, lapply(corticogenesis_GO, function(g) {
  
  g <- g[which(g %in% rownames(sc_seu))]
  
  Matrix::colMeans(logcounts(sc_pseudo)[g,])
  
}))

rownames(sc_seu_cortico_GOBP) <- gsub(" \\(GO:[0-9]+\\)$", "", rownames(sc_seu_cortico_GOBP)) #to simplify the gene sets names

sc_seu_cortico_GOBP <- sc_seu_cortico_GOBP[,mixedorder(colnames(sc_seu_cortico_GOBP))] #to put them in alphabetical order
```

Then, we can visualize the relative expression in a Heatmap to assess which biological processes charachterize more our mapped clusters. 

<details>
<summary><strong>Show the code (simplifying labels)</strong></summary>
```{r}
#this annotation replicates the one in Figure .. and aggregates cell types in major groups
cortico_subclass_groups <- colnames(corticogenesis_preferential_GO$GO_Biological_Process_2025$preferential)
cortico_subclass_groups[which(cortico_subclass_groups %in% c('L23IT', 'L35IT', 'L6IT', 'L6NIT'))] <- 'matEN'
cortico_subclass_groups[which(cortico_subclass_groups %in% c('LAMP5', 'SST', 'PVALB', 'VIP'))] <- 'matIN'
cortico_subclass_groups[which(cortico_subclass_groups %in% c('imIT', 'imNIT', 'eEN', 'miEN'))] <- 'immEN'
cortico_subclass_groups[which(cortico_subclass_groups %in% c('eIN', 'imIN'))] <- 'immIN'
cortico_subclass_groups[which(cortico_subclass_groups %in% c('Opc', 'Oligo', 'Astro'))] <- 'maGlia'
cortico_subclass_groups[which(cortico_subclass_groups %in% c('Micro'))] <- 'miGlia'
cortico_subclass_groups[which(cortico_subclass_groups %in% c('RG', 'cRG', 'IPC'))] <- 'Prog'

cortico_subclass_groups <- factor(cortico_subclass_groups, 
                                  levels = c('Prog', 'immEN', 'immIN', 'matEN', 'matIN', 'maGlia', 'miGlia')) 

cortico_gobp_groups <- factor(c(rep('Astro', 4), rep('Oligo', 3), rep('Opc', 3), rep('OligoGlia', 2), rep('matEN', 4), rep('matIN', 4), rep('immEN', 4), rep('Micro', 4), rep('Prog', 4), rep('Stress', 4)), levels = c('Prog', 'immEN', 'matEN', 'matIN', 'Opc', 'Oligo', 'OligoGlia', 'Astro', 'Micro', 'Stress'))

cortico_gobp_pe <- corticogenesis_preferential_GO$GO_Biological_Process_2025$preferential[names(corticogenesis_GO),]

rownames(cortico_gobp_pe) <- gsub(" \\(GO:[0-9]+\\)$", "", rownames(cortico_gobp_pe))
```
</details>

<details>
<summary><strong>Show the code (plotting heatmap)</strong></summary>
```{r, eval=F}
ht1 <- Heatmap(
  cortico_gobp_pe,
  name = 'preferential\nexpression',
  width = unit(ncol(cortico_gobp_pe) * 4.2, 'mm'), #4.2, 18,8
  height = unit(nrow(cortico_gobp_pe) * 4.2, 'mm'),
  show_row_dend = FALSE,
  show_column_dend = FALSE,
  row_title_rot = 0,
  row_names_gp = gpar(fontsize = 9),
  column_title_rot = 90,
  column_split = cortico_subclass_groups,
  cluster_column_slices = FALSE,
  row_split = cortico_gobp_groups,
  cluster_row_slices = FALSE,
  column_title_gp = gpar(fontsize = 0)
)

ht2 <- Heatmap(
  t(scale(t(sc_seu_cortico_GOBP))),
  name = 'scaled\nexpression',
  width = unit(ncol(sc_seu_cortico_GOBP) * 4.2, 'mm'),
  cluster_columns = TRUE, 
  row_names_gp = gpar(fontsize = 9),
  right_annotation = rowAnnotation(max = anno_barplot(apply(sc_seu_cortico_GOBP, 1, max), 
                                                      gp = gpar(fill = 'black')), 
                                   annotation_name_side = 'top', 
                                   annotation_name_rot = 0), 
  bottom_annotation = HeatmapAnnotation(annotation = mapped_sc_pseudo$annotation$Best.Annotation[colnames(sc_seu_cortico_GOBP)], 
                      col = list(annotation = corticogenesis_palette), 
                      show_legend = FALSE,
                      show_annotation_name = FALSE), 
  show_column_dend = FALSE,
)

ht_list <- ht1 + ht2
draw(ht_list, heatmap_legend_side = "left")
```
</details>

```{r, echo=FALSE}
ht1 <- Heatmap(
  cortico_gobp_pe,
  name = 'preferential\nexpression',
  width = unit(ncol(cortico_gobp_pe) * 4.2, 'mm'), #4.2, 18,8
  height = unit(nrow(cortico_gobp_pe) * 4.2, 'mm'),
  show_row_dend = FALSE,
  show_column_dend = FALSE,
  row_title_rot = 0,
  row_names_gp = gpar(fontsize = 9),
  column_title_rot = 90,
  column_split = cortico_subclass_groups,
  cluster_column_slices = FALSE,
  row_split = cortico_gobp_groups,
  cluster_row_slices = FALSE,
  column_title_gp = gpar(fontsize = 0)
)

ht2 <- Heatmap(
  t(scale(t(sc_seu_cortico_GOBP))),
  name = 'scaled\nexpression',
  width = unit(ncol(sc_seu_cortico_GOBP) * 4.2, 'mm'),
  cluster_columns = TRUE, 
  row_names_gp = gpar(fontsize = 9),
  right_annotation = rowAnnotation(max = anno_barplot(apply(sc_seu_cortico_GOBP, 1, max), 
                                                      gp = gpar(fill = 'black')), 
                                   annotation_name_side = 'top', 
                                   annotation_name_rot = 0), 
  bottom_annotation = HeatmapAnnotation(annotation = mapped_sc_pseudo$annotation$Best.Annotation[colnames(sc_seu_cortico_GOBP)], 
                      col = list(annotation = corticogenesis_palette), 
                      show_legend = FALSE,
                      show_annotation_name = FALSE), 
  show_column_dend = FALSE,
)

ht_list <- ht1 + ht2
```

```{r ch4-fig7, fig.width=15, fig.height=8, fig.cap="Heatmap of corticogenesis-specific GO biological processes in resource and mapped clusters.", out.width="99%",echo=F, eval=T, fig.align='center'}

draw(ht_list, 
     heatmap_legend_side = "left",
     padding = unit(c(5, 5, 2, 80), "mm"))
```

This heatmap shows that generally the biological processes match the annotations, with radial glia clusters displaying higher expression of processes associated with proliferation and glial metabolism, but we can also see that clusters 19 and 23 show high expression of stress-related processes, while displaying low expression of the terms more related to radial glia, their assigned annotation. This could explain why cluster 23 has such a low mapping confidence and suggest that these clusters are composed by early stressed cells.

The same type of analysis can be done with the neurogenesis network:
<details>
<summary><strong>Show the code (neurogenesis GO code)</strong></summary>
```{r, eval=FALSE}
sc_seu_neuro_GOBP <- do.call(rbind, lapply(neurogenesis_GO, function(g) {
  
  g <- g[which(g %in% rownames(sc_seu))]
  
  Matrix::colMeans(logcounts(sc_pseudo)[g,])
  
}))

rownames(sc_seu_neuro_GOBP) <- gsub(" \\(GO:[0-9]+\\)$", "", rownames(sc_seu_neuro_GOBP))
sc_seu_neuro_GOBP <- sc_seu_neuro_GOBP[,mixedorder(colnames(sc_seu_neuro_GOBP))]


neuro_gobp_pe <- neurogenesis_preferential_GO$GO_Biological_Process_2025$activity[names(neurogenesis_GO),]


neuroTrends <- do.call(cbind, lapply(rownames(neuro_gobp_pe), function(i)
  smooth.spline(1:length(neuro_gobp_pe[i,]), 
                neuro_gobp_pe[i,], spar = 1)$y))

colnames(neuroTrends) <- rownames(neuro_gobp_pe)

neuroTrends <- t(neuroTrends)[names(neurogenesis_GO),]
neuroTrends <- neuroTrends[order(apply(neuroTrends, 1, which.max), Matrix::rowMeans(neuroTrends)),]

rownames(neuroTrends) <- gsub(" \\(GO:[0-9]+\\)$", "", rownames(neuroTrends))

stage_palette <- unique(neurogenesis_sce$Stages_color)
names(stage_palette) <- unique(neurogenesis_sce$Stages)

h1 <- Heatmap(t(scale(t(neuroTrends))), 
              cluster_columns = F, 
              cluster_rows = F,
              bottom_annotation = HeatmapAnnotation(df=data.frame(stage=neurogenesis_sce$Stages), 
                                                    col=list(stage=stage_palette), 
                                                    show_legend = F, 
                                                    show_annotation_name = F), 
              name = 'inferred expression\n(z scaled)', 
              height = unit(100, 'mm'), 
              width = unit(30, 'mm'))

ht2 <- Heatmap(
  t(scale(t(sc_seu_neuro_GOBP[rownames(neuroTrends),]))),
  name = 'scaled\nexpression',
  width = unit(ncol(sc_seu_neuro_GOBP) * 4.2, 'mm'),
  cluster_columns = TRUE, 
  row_names_gp = gpar(fontsize = 9,
                      fontface =ifelse(colnames(t(scale(t(sc_seu_neuro_GOBP[rownames(neuroTrends),])))) %in% c("c23"), "bold", "plain")), 
  right_annotation = rowAnnotation(max = anno_barplot(apply(sc_seu_neuro_GOBP[rownames(neuroTrends),], 1, max), 
                                                      gp = gpar(fill = 'black')),
                                   annotation_name_side = 'top',
                                   annotation_name_rot = 0), 
  bottom_annotation = HeatmapAnnotation(annotation = mapped_sc_pseudo$annotation$Best.Annotation[colnames(sc_seu_cortico_GOBP)], 
                                        col = list(annotation = corticogenesis_palette), 
                                        show_legend = FALSE,
                                        show_annotation_name = FALSE), 
  show_column_dend = FALSE
)



ht_list <- h1 + ht2

draw(ht_list, heatmap_legend_side = "left")
```
</details>
```{r, echo=FALSE}
sc_seu_neuro_GOBP <- do.call(rbind, lapply(neurogenesis_GO, function(g) {
  
  g <- g[which(g %in% rownames(sc_seu))]
  
  Matrix::colMeans(logcounts(sc_pseudo)[g,])
  
}))

rownames(sc_seu_neuro_GOBP) <- gsub(" \\(GO:[0-9]+\\)$", "", rownames(sc_seu_neuro_GOBP))
sc_seu_neuro_GOBP <- sc_seu_neuro_GOBP[,mixedorder(colnames(sc_seu_neuro_GOBP))]


neuro_gobp_pe <- neurogenesis_preferential_GO$GO_Biological_Process_2025$activity[names(neurogenesis_GO),]


neuroTrends <- do.call(cbind, lapply(rownames(neuro_gobp_pe), function(i)
  smooth.spline(1:length(neuro_gobp_pe[i,]), 
                neuro_gobp_pe[i,], spar = 1)$y))

colnames(neuroTrends) <- rownames(neuro_gobp_pe)

neuroTrends <- t(neuroTrends)[names(neurogenesis_GO),]
neuroTrends <- neuroTrends[order(apply(neuroTrends, 1, which.max), Matrix::rowMeans(neuroTrends)),]

rownames(neuroTrends) <- gsub(" \\(GO:[0-9]+\\)$", "", rownames(neuroTrends))

stage_palette <- unique(neurogenesis_sce$Stages_color)
names(stage_palette) <- unique(neurogenesis_sce$Stages)

h1 <- Heatmap(t(scale(t(neuroTrends))), 
              cluster_columns = F, 
              cluster_rows = F,
              bottom_annotation = HeatmapAnnotation(df=data.frame(stage=neurogenesis_sce$Stages), 
                                                    col=list(stage=stage_palette), 
                                                    show_legend = F, 
                                                    show_annotation_name = F), 
              name = 'inferred expression\n(z scaled)', 
              height = unit(100, 'mm'), 
              width = unit(30, 'mm'))

ht2 <- Heatmap(
  t(scale(t(sc_seu_neuro_GOBP[rownames(neuroTrends),]))),
  name = 'scaled\nexpression',
  width = unit(ncol(sc_seu_neuro_GOBP) * 4.2, 'mm'),
  cluster_columns = TRUE, 
  row_names_gp = gpar(fontsize = 9,
                      fontface =ifelse(colnames(t(scale(t(sc_seu_neuro_GOBP[rownames(neuroTrends),])))) %in% c("c23"), "bold", "plain")), 
  right_annotation = rowAnnotation(max = anno_barplot(apply(sc_seu_neuro_GOBP[rownames(neuroTrends),], 1, max), 
                                                      gp = gpar(fill = 'black')),
                                   annotation_name_side = 'top',
                                   annotation_name_rot = 0), 
  bottom_annotation = HeatmapAnnotation(annotation = mapped_sc_pseudo$annotation$Best.Annotation[colnames(sc_seu_cortico_GOBP)], 
                                        col = list(annotation = corticogenesis_palette), 
                                        show_legend = FALSE,
                                        show_annotation_name = FALSE), 
  show_column_dend = FALSE
)



ht_list <- h1 + ht2
```


```{r ch4-fig8, fig.width=10, fig.height=7, fig.cap="Heatmap of neurogenesis-specific GO biological processes in resource and mapped clusters.", out.width='85%', echo=F, eval=T, fig.align='center'}
draw(ht_list, 
     heatmap_legend_side = "left",
     padding = unit(c(5, 1, 2, 90), "mm"))
```


Again, the cluster with the highest neuroinflammatory response (indicative of stress) is cluster 23. 
Thanks to the use of the neurogenesis-specific network we can appreciate how neuronal specific processes are expressed in clusters assigned to the immature neuron annotations and not in those labelled as progenitors. 

Additionally, we can visualize the mapped points directly on the eTraces, to see how similar they are to clusters in the resource network based on gene expression. 
The function to perform such analysis is `map_eTrace`, which requires the following inputs:

 - `net`: the reference network to use
 - `mapped_obj`: the result of `mapNetwork`
 - the inputs required to run `plot_eTrace` (see the Chapter \@ref(analysis))

```{r ch4-fig9, fig.cap="VIM and SYT1 eTrace in corticogenesis and mapped points", fig.show='hold', fig.align='center', out.width='50%'}
map_eTrace(net = corticogenesis_sce, 
         mapped_obj = mapped_sc_pseudo, 
         genes = 'VIM',
         main = "VIM")
map_eTrace(net = corticogenesis_sce, 
         mapped_obj = mapped_sc_pseudo, 
         genes = 'SYT1',
         main = "SYT1")
```

From this type on analysis we can clearly appreciate the distinction between radial glia-like clusters and more neuronal ones. Additionally, we can see at a glance which mapped points resemble more mature reference clusters, as age increases from left to right. The more rightward clusters are: 2, 9, 11, and 14. 
If check the percentage of cells belonging to the latest time point (4 months) across each cluster, 
we can see that those clusters are also those with the highest proportion of latest-stage cells:

```{r}
sort(apply(table(sc_seu$stage, paste0('c', sc_seu$seurat_clusters)), 2, function(i) {i/sum(i)})['Organoid-4M',]*100)
```

We can also obtain markers for each cluster using the Seurat function `FindAllMarkers` and plot those genes in the eTraces.

```{r, message=FALSE, warning=FALSE}
markers <- FindAllMarkers(sc_seu, 
                          only.pos = TRUE, 
                          min.pct = 0.5, 
                          logfc.threshold = 1)

markers <- markers[which(markers$p_val_adj < 0.001),]

markers <- split(markers$gene, markers$cluster)
```


```{r, message=FALSE, warning=FALSE, eval=FALSE}
lapply(names(markers), function(i) {
        g <- markers[[i]]
        g <- g[which(g %in% rownames(corticogenesis_sce))]
        plot_eTrace(net = corticogenesis_sce, 
                    genes = g, 
                    main = paste("markers of cluster",i))
})
```

```{r, eval=T, echo=FALSE}
genes_markers <- lapply(names(markers), function(i) {
                        g <- markers[[i]]
                        g <- g[which(g %in% rownames(corticogenesis_sce))]
})
```


```{r ch4-fig10, message=FALSE, warning=FALSE, fig.show='hold', fig.align='left', out.width='48%', eval=T, echo=FALSE, fig.cap="eTraces of markers of selected clusters."}
plot_eTrace(net = corticogenesis_sce, 
                    genes = genes_markers[[14]], 
                    main = paste("markers of cluster",names(markers)[[14]]))
plot_eTrace(net = corticogenesis_sce, 
                    genes = genes_markers[[16]], 
                    main = paste("markers of cluster",names(markers)[[16]]))
plot_eTrace(net = corticogenesis_sce, 
                    genes = genes_markers[[22]], 
                    main = paste("markers of cluster",names(markers)[[22]]))
plot_eTrace(net = corticogenesis_sce, 
                    genes = genes_markers[[23]], 
                    main = paste("markers of cluster",names(markers)[[23]]))
```
Again, it is easy to distinguish between more neuronal clusters and more radial glia-like clusters, but also we can find some clusters that are more inhibitory neurons-like (e.g. clusters 22 and 11), and cluster 23 markers which are highly expressed in microglia too, pointing to a possible transcriptional signature stress-related.
