[{"path":"index.html","id":"summary","chapter":"1 Summary","heading":"1 Summary","text":"tutorial use neuRoDev package doi explore processes corticogenesis. following chapters allow inspection resource compendium including analyses shown article additional examples mode use. also included interactive eTrace tool investigate patterns gene(s) expression instantaneously.","code":""},{"path":"index.html","id":"installation","chapter":"1 Summary","heading":"1.1 Installation","text":"install neuRoDev package Github:neuRoDev package uses SingleCellExperiment objects store corticogenesis, neurogenesis, gliogenesis resources.data used tutorial available download .","code":"\ninstall.packages(\"devtools\")\n\ndevtools::install_github(\"https://github.com/davilavelderrainlab/neuRoDev\")"},{"path":"network.html","id":"network","chapter":"2 Network exploration","heading":"2 Network exploration","text":"","code":""},{"path":"network.html","id":"loading-necessary-libraries-and-data","chapter":"2 Network exploration","heading":"2.1 Loading necessary libraries and data","text":"chapter demonstrates explore reference networks corticogenesis, neurogenesis gliogenesis. provides code chunks reproduce results paper figures examples use resource.","code":""},{"path":"network.html","id":"loading-the-right-libraries","chapter":"2 Network exploration","heading":"2.1.1 Loading the right libraries","text":"","code":"\n# functions package\nlibrary(neuRoDev)\n# extra packages\nlibrary(SingleCellExperiment)\nlibrary(gtools)"},{"path":"network.html","id":"loading-the-networks-necessary-objects","chapter":"2 Network exploration","heading":"2.1.2 Loading the networks necessary objects","text":"data used tutorial can downloaded . functions corticogenesis.sce, neurogenesis.sce, gliogenesis.sce can used directly download data. functions also load data. default, functions download data neuRoDev cache folder, preferred directory can given changing directory variable. file already found directory, object loaded, otherwise first downloaded:someone wants start count matrices, stored unique matrix associated metadata .reference datasets comprise:signatures: contains sample-wise signatures cluster.signatures: contains sample-wise signatures cluster.logcounts: contains normalized pseudobulk expression cluster.logcounts: contains normalized pseudobulk expression cluster.colData: saved information networks, including name cluster, study, age days stages, subclass/subtype, starting class subclass annotation (RefClass RefSubClass), x y UMAP coordinates, etc.colData: saved information networks, including name cluster, study, age days stages, subclass/subtype, starting class subclass annotation (RefClass RefSubClass), x y UMAP coordinates, etc.correlations: contains correlation values cluster signatures cell type reference signatures. Saved metadata.correlations: contains correlation values cluster signatures cell type reference signatures. Saved metadata.network: comprises edges, distances, adjacency matrix, indexes. Saved metadata.network: comprises edges, distances, adjacency matrix, indexes. Saved metadata.subclass_psb: contains additional SingleCellExperiment object subclassesâ€™ pseudobulk logcounts preferential expression. Saved metadata.subclass_psb: contains additional SingleCellExperiment object subclassesâ€™ pseudobulk logcounts preferential expression. Saved metadata.stage_psb: contains additional SingleCellExperiment object stagesâ€™ pseudobulk logcounts preferential expression. Saved metadata.stage_psb: contains additional SingleCellExperiment object stagesâ€™ pseudobulk logcounts preferential expression. Saved metadata.can start analysis exploration reference networks.","code":"\ncorticogenesis_sce <- corticogenesis.sce(directory = '~/Downloads')\nneurogenesis_sce <- neurogenesis.sce(directory = '~/Downloads')\ngliogenesis_sce <- gliogenesis.sce(directory = '~/Downloads')\nstages_palette <- unique(corticogenesis_sce$Stages_color)\nnames(stages_palette) <- unique(corticogenesis_sce$Stages)\n\ncorticogenesis_palette <- unique(corticogenesis_sce$SubClass_color)\nnames(corticogenesis_palette) <- unique(corticogenesis_sce$SubClass)\n\nneurogenesis_palette <- unique(neurogenesis_sce$SubClass_color)\nnames(neurogenesis_palette) <- unique(neurogenesis_sce$SubClass)\n\ngliogenesis_palette <- unique(gliogenesis_sce$SubClass_color)\nnames(gliogenesis_palette) <- unique(gliogenesis_sce$SubClass)"},{"path":"network.html","id":"network-visualizations","chapter":"2 Network exploration","heading":"2.2 Network visualizations","text":"","code":""},{"path":"network.html","id":"subclass-or-subclass-labels-and-colors","chapter":"2 Network exploration","heading":"2.2.1 SubClass (or SubClass) labels and colors","text":"show possible visualize network different cell types age cluster. First, need obtain UMAP plot network, build upon correlations reference signatures. color clusters can provide labels associated color, thus making possible visualize kind label.network-specific dataframes retain information cluster name, stage, age days, original label, annotations etc.\nshow just part table:Subclass-based colors corticogenesis, neurogenesis gliogenesis networks.\nplotNetwork recreates plots figure X, figure X, figure X.\ninputs :net = SingleCellExperiment object.color_attr = column used define annotations used color plot. Defaults â€œSubClassâ€.label_attr = column used define annotations used label plot. Defaults â€œSubClassâ€.col_vector = color palette use color plot. Defaults SubClass_color, internal palette.output show 2D-UMAP representation networks, dot single cluster.\nFigure 2.1: Corticogenesis subclasses.\n\nFigure 2.2: Neurogenesis subclasses.\n\nFigure 2.3: Gliogenesis subclasses.\nshow stage maturation cluster, can plot network just modify color_attr match stages. default displays cell types colored stage subclass label, however, possible also display stages labels passing â€œStagesâ€ label_attr parameter.Interestingly, clusters capture age gradient center network spreads towards edges. trend detectable also within single subclass, showing patterns expression continuous time.\nFigure 2.4: Corticogenesis stages.\n\nFigure 2.5: Neurogenesis stages.\n\nFigure 2.6: Gliogenesis stages.\n","code":"\nplotNetwork(net = corticogenesis_sce)\nplotNetwork(net = neurogenesis_sce)\nplotNetwork(net = gliogenesis_sce)\nplotNetwork(net = corticogenesis_sce, color_attr = 'Stages')\nplotNetwork(net = neurogenesis_sce, color_attr = 'Stages')\nplotNetwork(net = gliogenesis_sce, color_attr = 'Stages')"},{"path":"network.html","id":"visualize-the-expression-of-genes-or-gene-sets","chapter":"2 Network exploration","heading":"2.3 Visualize the expression of genes or gene sets","text":"cluster computed pseudobulk profile. , can explore gene expression network.plotNetworkScore shows values numerical vector across network, either raw smoothed considering network structure (leads homogeneous values clusters neighborhood).\ninputs :net = SingleCellExperiment object.score = score matrix, one value per gene (rows) per cluster (columns). defaults pseudobulk expression matrix contained SingleCellExperiment object.genes = optional, given retrieve specific gene values scorelabel_attr = column used define annotations used label plot. Defaults â€œSubClassâ€.smooth = whether smooth values based network structure. Defaults FALSE.Additional plotting parameters (see ?plotNetworkScore).output show 2D-UMAP representation networks, dot single cluster, colored based given score.\nFigure 2.7: VIP gene expression corticogenesis, without smoothing.\n\nFigure 2.8: NEUROD6 smoothed expression neurogenesis.\n\nFigure 2.9: OLIG1 smoothed expression gliogenesis.\ncan also look average expression specific group genes interest. show manually selected cell cycle genes network.\nFigure 2.10: Cell cycle genes expression corticogenesis.\n","code":"\n# no smoothing - one gene - no labels\nplotNetworkScore(net = corticogenesis_sce,\n                 genes = 'VIP',\n                 smooth = FALSE,\n                 title = \"raw expression\")\n\n#smoothing considering 20 neighbors - one gene\nplotNetworkScore(net = corticogenesis_sce,\n                 genes = 'VIP',\n                 smooth = TRUE, \n                 n_nearest = 20,\n                 title = \"smoothed expression\")\nplotNetworkScore(net = neurogenesis_sce,\n                 genes = 'NEUROD6',\n                 smooth = TRUE, \n                 n_nearest = 20)\nplotNetworkScore(net = gliogenesis_sce,\n                 genes = 'OLIG1',\n                 smooth = TRUE, \n                 n_nearest = 20)\n#manually selected cell cycle genes\ncell_cycle_genes <- c(\n  \"CCND1\", \"CCND2\", \"CCND3\", \"CCNE1\", \"CCNE2\", \"CCNA2\", \"CCNB1\", \"CCNB2\",\n  \"CDK1\", \"CDK2\", \"CDK4\", \"CDK6\",\n  \"CDKN1A\", \"CDKN1B\", \"CDKN2A\", \"CDKN2B\"\n)\nplotNetworkScore(net = corticogenesis_sce,\n                 genes = cell_cycle_genes,\n                 smooth = TRUE, \n                 n_nearest = 20,\n                 title = \"Cell cycle\")"},{"path":"network.html","id":"subclass-composition-across-ages","chapter":"2 Network exploration","heading":"2.4 SubClass composition across ages","text":"Cortical development highly dynamic process, cell types emerging different stages life due progenitors changing fate based developmental period. explore happens, can look cell type composition time.","code":""},{"path":"network.html","id":"proportions-across-ages","chapter":"2 Network exploration","heading":"2.4.1 Proportions across ages","text":"assess subclasses change time, can take look proportions evolve, leveraging knowledge cell type time conception.Taking example corticogenesis, show dynamics cell type development. Radial glia early immature neurons) high first time points, decrease later , mature neurons show opposite trend. Notably, deep layer neurons appear first, upper layers emerge later. Moreover, glia subclasses present already early stages (OPCs astrocytes), later present oligodendrocytes .\nFigure 2.11: Corticogenesis subclasses proportions.\nIncreasing resolution going neuron-specific network, can observe progenitors start decrease around peak neurogenesis (w14-16), mature neurons predominant birth . Furthermore, neuronal subclasses define depict inside-stereotypical way cortical development. Deep non intratelencephalic (Non-) followed intratelencephalic () ones, upper layer neurons (ExN-L2-3-) last produced.\nFigure 2.12: Neurogenesis subclasses proportions.\ngliogenesis network, instead, allowed us describe fine radial glia subclasses. early stages can observe variety progenitors, nice distinction different cell cycle phases (G2M S).\nprocess comprise two major lineages: astrogenesis oligodendrogenesis. Cell types two branches appear already w10 w18. Immature OPCs coming ganglionic eminences migrate towards cortex, followed radial glia generating astrocytes concluding neurogenesis (peak w18-w25).\nFigure 2.13: Gliogenesis Subclasses proportions.\n","code":"\nunique_ages <- mixedsort(unique(corticogenesis_sce$Age))\nordered_ages <- c(unique_ages[grep('w', unique_ages)], unique_ages[grep('d', unique_ages)], unique_ages[grep('m', unique_ages)], unique_ages[grep('yr', unique_ages)])\n\nstages.indexes <- unlist(lapply(names(stages_palette), function(i) {\n  strsplit(i, \"-\")[[1]][1]\n  }))\ncorticogenesis_subclass_proportion <- table(corticogenesis_sce$SubClass, corticogenesis_sce$Age)\n\ncorticogenesis_subclass_proportion <- t(t(corticogenesis_subclass_proportion)/colSums(corticogenesis_subclass_proportion))\n\n\nneurogenesis_subclass_proportion <- table(neurogenesis_sce$SubClass, neurogenesis_sce$Age)\n\nneurogenesis_subclass_proportion <- t(t(neurogenesis_subclass_proportion)/colSums(neurogenesis_subclass_proportion))\n\n\ngliogenesis_subclass_proportion <- table(gliogenesis_sce$SubClass, gliogenesis_sce$Age)\n\ngliogenesis_subclass_proportion <- t(t(gliogenesis_subclass_proportion)/colSums(gliogenesis_subclass_proportion))\nbarplot(corticogenesis_subclass_proportion[,ordered_ages], \n        col = corticogenesis_palette[rownames(corticogenesis_subclass_proportion)], \n        las = 2, \n        ylab = 'SubClass proportion')\nbarplot(neurogenesis_subclass_proportion[,ordered_ages], \n        col = neurogenesis_palette[rownames(neurogenesis_subclass_proportion)], \n        las = 2, \n        ylab = 'SubClass proportion')\nbarplot(gliogenesis_subclass_proportion[,ordered_ages[which(ordered_ages %in% colnames(gliogenesis_subclass_proportion))]],\n        col = gliogenesis_palette[rownames(gliogenesis_subclass_proportion)], \n        las = 2, \n        ylab = 'SubClass proportion')"},{"path":"network.html","id":"compute-the-cumulative-cluster-number-proportion","chapter":"2 Network exploration","heading":"2.4.2 Compute the cumulative cluster number proportion","text":"Another way looking cell type dynamics cortical development involves examining number clusters assigned subtype across developmental stagesThe cumulative sum gives us different levels information. First, can observe time point cell type starts populate cortex; second, can see proportion clusters increases fastest, showing prevalence generation maturation subclasses; third, can appreciate period time cell type reaches plateau, .e.Â generated anymore fully matured.\nexample: radial glia generally reach plateau birth, similar way behave InN-Immature, time leaves place mature inhibitory neurons. Oligodendrocytes, instead, appear postnatally peak around late childhood reach plateau adulthood, accordance processes synaptogenesis myelination.\nFigure 2.14: Corticogenesis cumulative sum subclasses cells time.\nneurogenesis evident difference maturing differentiated excitatory neurons subclasses. Moreover, difference deep upper layer neurons, particularly non intratelencephalic (Non-) intratelencephalic () branches, evident also .\nFigure 2.15: Neurogenesis cumulative sum subclasses cells time.\ngliogenesis main difference progenitors (radial glia OPCs), mature cell types (oligodendrocytes astrocytes).\nFigure 2.16: Gliogenesis cumulative sum subclasses cells time.\n","code":"\n# here for each row (i.e. for each subclass/subtype) \n# ordered by age, we divide the cumulative sum of \n# clusters by the total number of clusters to obtain \n# subclass/subtype proportion for each stage\n\ncorticogenesis_subclass_cumsum <- t(\n  apply(X = table(corticogenesis_sce$SubClass, corticogenesis_sce$Stages)[,mixedsort(unique(corticogenesis_sce$Stages))],  \n        MARGIN =  1, \n        FUN = function(i) {\n  cumsum(i/sum(i)) \n})) \n\nneurogenesis_subclass_cumsum <- t(apply(table(neurogenesis_sce$SubClass, neurogenesis_sce$Stages)[,mixedsort(unique(neurogenesis_sce$Stages))], 1, function(i) {\n  cumsum(i/sum(i))\n}))\n\ngliogenesis_subclass_cumsum <- t(apply(table(gliogenesis_sce$SubClass, gliogenesis_sce$Stages)[,mixedsort(unique(gliogenesis_sce$Stages))], 1, function(i) {\n  cumsum(i/sum(i))\n}))"},{"path":"network.html","id":"stages-composition-across-subclasses","chapter":"2 Network exploration","heading":"2.5 Stages composition across subclasses","text":"follow stage composition among different subclasses, can look proportion clusters age within identified subclasses. can first order mean age, calculate stages fractions.\nFigure 2.17: Corticogenesis subclasses proportions.\n\nFigure 2.18: Neurogenesis subclasses proportions.\n\nFigure 2.19: Gliogenesis subclasses proportions.\n","code":"\ncortico_mean_age <- unlist(lapply(unique(corticogenesis_sce$SubClass), function(i) {\n  subclass_days <- corticogenesis_sce$Days[which(corticogenesis_sce$SubClass == i)]\n  log_subclass_days <- log10(subclass_days)\n  mean_age <- mean(log_subclass_days)\n}))\nnames(cortico_mean_age) <- unique(corticogenesis_sce$SubClass)\n\nneuro_mean_age <- unlist(lapply(unique(neurogenesis_sce$SubClass), function(i) {\n  subclass_days <- neurogenesis_sce$Days[which(neurogenesis_sce$SubClass == i)]\n  log_subclass_days <- log10(subclass_days)\n  mean_age <- mean(log_subclass_days)\n}))\nnames(neuro_mean_age) <- unique(neurogenesis_sce$SubClass)\n\nglio_mean_age <- unlist(lapply(unique(gliogenesis_sce$SubClass), function(i) {\n  subclass_days <- gliogenesis_sce$Days[which(gliogenesis_sce$SubClass == i)]\n  log_subclass_days <- log10(subclass_days)\n  mean_age <- mean(log_subclass_days)\n}))\nnames(glio_mean_age) <- unique(gliogenesis_sce$SubClass)\ncorticogenesis_stage_proportion <- table(corticogenesis_sce$Stages, \n                                         corticogenesis_sce$SubClass)\n\ncorticogenesis_stage_proportion <- t(t(corticogenesis_stage_proportion)/colSums(corticogenesis_stage_proportion))\n\n\nneurogenesis_stage_proportion <- table(neurogenesis_sce$Stages, \n                                       neurogenesis_sce$SubClass)\n\nneurogenesis_stage_proportion <- t(t(neurogenesis_stage_proportion)/colSums(neurogenesis_stage_proportion))\n\n\ngliogenesis_stage_proportion <- table(gliogenesis_sce$Stages, \n                                      gliogenesis_sce$SubClass)\n\ngliogenesis_stage_proportion <- t(t(gliogenesis_stage_proportion)/colSums(gliogenesis_stage_proportion))\nbarplot(corticogenesis_stage_proportion[,names(cortico_mean_age[order(cortico_mean_age)])],\n        col = stages_palette[rownames(corticogenesis_stage_proportion)], \n        las = 2, \n        ylab = 'Stages proportion')\nbarplot(neurogenesis_stage_proportion[,names(neuro_mean_age[order(neuro_mean_age)])],\n        col = stages_palette[rownames(neurogenesis_stage_proportion)], \n        las = 2, \n        ylab = 'Stages proportion')\nbarplot(gliogenesis_stage_proportion[,names(glio_mean_age[order(glio_mean_age)])],\n        col = stages_palette[rownames(gliogenesis_stage_proportion)], \n        las = 2, \n        ylab = 'Stages proportion')"},{"path":"analysis.html","id":"analysis","chapter":"3 Analysis Tools","heading":"3 Analysis Tools","text":"","code":""},{"path":"analysis.html","id":"loading-necessary-libraries-and-data-1","chapter":"3 Analysis Tools","heading":"3.1 Loading necessary libraries and data","text":"","code":""},{"path":"analysis.html","id":"loading-the-right-libraries-1","chapter":"3 Analysis Tools","heading":"3.1.1 Loading the right libraries","text":"","code":"\n# functions package\nlibrary(neuRoDev)\n# extra packages\nlibrary(readxl)\nlibrary(ComplexHeatmap)"},{"path":"analysis.html","id":"loading-the-networks-necessary-objects-1","chapter":"3 Analysis Tools","heading":"3.1.2 Loading the networks necessary objects","text":"Load preferential expression Gene Ontology Biological Processes (BP), Molecular Functions (MF), Cellular Components (CC). objects available . object list containing preferential expression scores one three reference networks three ontologies (BP, MF, CC). element list contains activity (activity) derived Gene Set Variation Analysis (one value per gene set cluster) preferential expression scores (preferential; one value per gene set subclass).gene set enrichment values can found files corticogenesis_preferentialEnrichR, neurogenesis_preferentialEnrichR, gliogenesis_preferentialEnrichR.Load preferentially expressed gene list. objects available : â€¦","code":"\ncorticogenesis_sce <- corticogenesis.sce(directory = '~/Downloads')\nneurogenesis_sce <- neurogenesis.sce(directory = '~/Downloads')\ngliogenesis_sce <- gliogenesis.sce(directory = '~/Downloads')\ncorticogenesis_preferential_GO <- readRDS('~/Downloads/corticogenesis_preferential_GO.rds')\nneurogenesis_preferential_GO <- readRDS('~/Downloads/neurogenesis_preferential_GO.rds')\ngliogenesis_preferential_GO <- readRDS('~/Downloads/gliogenesis_preferential_GO.rds')\ncorticogenesis_pe_genes <- readRDS(\"~/Downloads/corticogenesis_subclass_preferential_genes.rds\")\nneurogenesis_pe_genes <- readRDS(\"~/Downloads/neurogenesis_subclass_preferential_genes.rds\")\ngliogenesis_pe_genes <- readRDS(\"~/Downloads/gliogenesis_subclass_preferential_genes.rds\")"},{"path":"analysis.html","id":"etraces","chapter":"3 Analysis Tools","heading":"3.2 eTraces","text":"developed intuitive way directly visualize molecular phenotype score cluster reference networks, called eTrace (expression Trace). provide interactive tool directly assess (log-normalized) expression input genes gene sets, get expression enrichment trends (statistically robust) required install package follow code mentioned chapter.function used visualize eTraces plot_eTrace. function requires inputs, mandatory one reference network (net):net: reference network use.genes: specific gene set genes derive score plot. genes given, output averaged score genes. defaults NULL, user can directly provide score per cluster (see score). genes given score matrix selected, genes score matrix considered.score: can vector, one value per cluster, matrix. matrix given together genes (see genes), values selected genes present matrix shown. defaults log-normalized expression values contained net logcounts.expression_enrichment: defines whether compute expression enrichment given genes, statistically robust way looking expression. TRUE, score used expression enrichment score, regardless put score. defaults FALSE.plotting fine-tuning inputs, see ?plot_eTrace information.\nFigure 3.1: Single gene eTrace corticogenesis.\n\nFigure 3.2: Single gene expression enrichment eTrace corticogenesis.\nWorking gene sets:\nFigure 3.3: Gene set activity score eTrace corticogenesis.\n\nFigure 3.4: Gene set eTrace corticogenesis.\n\nFigure 3.5: Genes set expression enrichment eTrace corticogenesis.\nexpression enrichment values can obtained using function get_eTrace, requires input:\n- reference network (net),\n- genes use (genes),\n- number random genes use comparison (nRand; defaults 100).Additionally, possible look within-lineage specific patterns expression subsetting networks. example, show expression patterns genes inside oligodendrogenesis- astrogenesis-specific trajectories differentiation:\nFigure 3.6: Single gene expression enrichment eTrace within astrogenesis.\n\nFigure 3.7: Single gene expression enrichment eTrace within oligodendrogenesis.\n","code":"\nplot_eTrace(corticogenesis_sce, \n            genes = 'SST', \n            main = 'SST - no enrichment')\nplot_eTrace(corticogenesis_sce, genes = 'PAX6', \n            expression_enrichment = TRUE, \n            main = 'PAX6 - enrichment')\nplot_eTrace(corticogenesis_sce, \n            score = corticogenesis_preferential_GO$GO_Biological_Process_2025$activity[\"Glycogen Biosynthetic Process (GO:0005978)\",], \n            main = 'Glycogen Biosynthesis')\nplot_eTrace(corticogenesis_sce, \n            genes = corticogenesis_pe_genes$Oligo, \n            main = 'Oligodendrocyte preferentially expressed genes')\nplot_eTrace(corticogenesis_sce, \n            genes = corticogenesis_pe_genes$Opc, \n            expression_enrichment = TRUE, \n            main = 'OPC preferentially expressed genes')\nastro_sce <- gliogenesis_sce[,-c(grep(gliogenesis_sce$SubClass, pattern=\"OPC\"),\n  grep(gliogenesis_sce$SubClass, pattern=\"Oli\"))] #removes everything that is oligodendroglia-related\n\noli_sce <- gliogenesis_sce[,c(grep(gliogenesis_sce$SubClass, pattern=\"OPC\"),\n  grep(gliogenesis_sce$SubClass, pattern=\"Oli\"))] #keeps only oligodendroglia-related\n\nplot_eTrace(astro_sce,\n            genes = \"SPARCL1\",\n            expression_enrichment = T,\n            main = \"SPARCL1 in astrogenesis\")\n\nplot_eTrace(oli_sce,\n            genes = \"MAG\",\n            expression_enrichment = T,\n            main = \"MAG in oligodendrogenesis\")"},{"path":"analysis.html","id":"interactive-etrace","chapter":"3 Analysis Tools","heading":"3.3 Interactive eTrace","text":"explore normalized expression expression enrichment levels (single) genes possible use interactive tool observe glance patterns ~70 years life.\ncan access one click three different resource levels input single gene gene set look patterns expression tima subclasses.\nðŸ” Click interactively visualize corticogenesis eTrace\n\nðŸ” Click interactively visualize neurogenesis eTrace\n\nðŸ” Click interactively visualize gliogenesis eTrace\n","code":""},{"path":"analysis.html","id":"expression-enrichment-across-stage-and-subclass","chapter":"3 Analysis Tools","heading":"3.4 Expression enrichment across stage and subclass","text":"alternative compact visualization expression enrichment subclasses stages can obtained using function plot_eMatrix. inputs listed , needed get_eTrace function:net: reference network use.genes: specific gene set genes derive expression enrichment.nRand: number random sets use expression enrichment calculation. Defaults 100.returns eMatrix showing columns subclasses, rows stages, values represent enrichment score.\nFigure 3.8: VIP eMatrix corticogenesis.\n\nFigure 3.9: NEUROD6 eMatrix neurogenesis.\n\nFigure 3.10: GFAP eMatrix gliogenesis.\n\nFigure 3.11: L6NIT preferentially expressed genes eMatrix corticogenesis.\npossible obtain eMatrix using function get_eMatrix, uses inputs plot_eMatrix.","code":"\nplot_eMatrix(net = corticogenesis_sce, \n             genes = 'VIP')\nplot_eMatrix(net = neurogenesis_sce, \n             genes = 'NEUROD6')\nplot_eMatrix(net = gliogenesis_sce, \n             genes = 'GFAP')\nplot_eMatrix(net = corticogenesis_sce, \n             genes = corticogenesis_pe_genes$L6NIT)"},{"path":"analysis.html","id":"visualization-of-enrichment-in-the-network","chapter":"3 Analysis Tools","heading":"3.5 Visualization of enrichment in the network","text":"described Chapter 2, can visualize cluster-wise scores directly UMAP network level. can done plotNetworkScore function, running get_eTrace.\nFigure 3.12: Gene expression enrichment corticogenesis network.\n","code":"\nexp_enrichment_oligo <- get_eTrace(net = corticogenesis_sce, \n                                   genes = corticogenesis_pe_genes$Oligo) #get scores\n\nplotNetworkScore(net = corticogenesis_sce, \n                 score = exp_enrichment_oligo$z, \n                 palette = 'BlGrRd', \n                 fix_alpha = TRUE, \n                 title = \"Enrichment: Oli preferential genes\")"},{"path":"analysis.html","id":"preferential-expression","chapter":"3 Analysis Tools","heading":"3.6 Preferential expression","text":"\nFigure 3.13: Top gene ontology biological processes corticogenesis.\n\nFigure 3.14: Top gene ontology biological processes neurogenesis.\n\nFigure 3.15: Top gene ontology biological processes gliogenesis.\nfocus corticogenesis-related processes also manually curated list Gene Ontology Biological Processes corticogenesis neurogenesis networks, available .","code":"\ntop_GO_bp_cortico_list <- apply(corticogenesis_preferential_GO$GO_Biological_Process_2025$preferential, 2, function(i) {\n  rownames(corticogenesis_preferential_GO$GO_Biological_Process_2025$preferential)[order(i, decreasing = TRUE)[seq(1,2)]]\n  }\n) #selecting top 2 processes by subclass\n\ntop_GO_bp_cortico <- corticogenesis_preferential_GO$GO_Biological_Process_2025$preferential[unique(as.vector(top_GO_bp_cortico_list)),]\n\nrownames(top_GO_bp_cortico) <- sub(\"\\\\s*\\\\(GO:\\\\d+\\\\)$\", \"\", rownames(top_GO_bp_cortico))\n\nh <- Heatmap(top_GO_bp_cortico[,levels(corticogenesis_sce$SubClass)], \n             name = 'preferential\\nexpression', \n             width = grid::unit(ncol(top_GO_bp_cortico)*4, 'mm'), \n             height = grid::unit(nrow(top_GO_bp_cortico)*4, 'mm'), \n             cluster_columns = FALSE, \n             rect_gp = gpar(color = 'black', lwd = 0.5))\ndraw(h, heatmap_legend_side = 'left')\ntop_GO_bp_neuro_list <- apply(neurogenesis_preferential_GO$GO_Biological_Process_2025$preferential, 2, function(i) {\n  rownames(neurogenesis_preferential_GO$GO_Biological_Process_2025$preferential)[order(i, decreasing = TRUE)[seq(1,2)]]\n  }\n)\n\ntop_GO_bp_neuro <- neurogenesis_preferential_GO$GO_Biological_Process_2025$preferential[unique(as.vector(top_GO_bp_neuro_list)),]\n\nrownames(top_GO_bp_neuro) <- sub(\"\\\\s*\\\\(GO:\\\\d+\\\\)$\", \"\", rownames(top_GO_bp_neuro))\n\nh_neuro <- Heatmap(top_GO_bp_neuro[,levels(neurogenesis_sce$SubClass)], \n                   name = 'preferential\\nexpression', \n                   width = grid::unit(ncol(top_GO_bp_neuro)*4, 'mm'), \n                   height = grid::unit(nrow(top_GO_bp_neuro)*4, 'mm'), \n                   cluster_columns = FALSE, \n                   rect_gp = gpar(color = 'black', lwd = 0.5))\ndraw(h_neuro, heatmap_legend_side = 'left')\ntop_GO_bp_glio_list <- apply(gliogenesis_preferential_GO$GO_Biological_Process_2025$preferential, 2, function(i) {\n  rownames(gliogenesis_preferential_GO$GO_Biological_Process_2025$preferential)[order(i, decreasing = TRUE)[seq(1,2)]]\n  }\n)\n\ntop_GO_bp_glio <- gliogenesis_preferential_GO$GO_Biological_Process_2025$preferential[unique(as.vector(top_GO_bp_glio_list)),]\n\nrownames(top_GO_bp_glio) <- sub(\"\\\\s*\\\\(GO:\\\\d+\\\\)$\", \"\", rownames(top_GO_bp_glio))\n\nh_glio <- Heatmap(top_GO_bp_glio[,levels(gliogenesis_sce$SubClass)], \n                  name = 'preferential\\nexpression', \n                  width = grid::unit(ncol(top_GO_bp_glio)*4, 'mm'), \n                  height = grid::unit(nrow(top_GO_bp_glio)*4, 'mm'), \n                  cluster_columns = FALSE, \n                  rect_gp = gpar(color = 'black', lwd = 0.5))\ndraw(h_glio, heatmap_legend_side = 'left')"},{"path":"mapping-sc.html","id":"mapping-sc","chapter":"4 Mapping Single-cell data","heading":"4 Mapping Single-cell data","text":"","code":""},{"path":"mapping-sc.html","id":"loading-necessary-libraries-and-data-2","chapter":"4 Mapping Single-cell data","heading":"4.1 Loading necessary libraries and data","text":"","code":""},{"path":"mapping-sc.html","id":"loading-the-right-libraries-2","chapter":"4 Mapping Single-cell data","heading":"4.1.1 Loading the right libraries","text":"","code":"\n# functions package\nlibrary(neuRoDev)\n# extra packages\nlibrary(Seurat)\nlibrary(ComplexHeatmap)\nlibrary(gtools)\nlibrary(ggplot2)\nlibrary(viridis)\nlibrary(Matrix)\nlibrary(SingleCellExperiment)"},{"path":"mapping-sc.html","id":"loading-the-networks-necessary-objects-2","chapter":"4 Mapping Single-cell data","heading":"4.1.2 Loading the networks necessary objects","text":"Load preferential expression Gene Ontology Biological Processes (BP), Molecular Functions (MF), Cellular Components (CC). objects available . object list containing preferential expression scores one three reference networks three ontologies (BP, MF, CC). element list contains activity (activity) derived Gene Set Variation Analysis (one value per gene set cluster) preferential expression scores (preferential; one value per gene set subclass).\ngene set enrichment values can found files corticogenesis_preferentialEnrichR, neurogenesis_preferentialEnrichR, gliogenesis_preferentialEnrichR.Load preferentially expressed gene list. objects available : â€¦Load manually curated Gene Ontology Biological Processes corticogenesis neurogenesis networks, available : â€¦\ngene sets manually curated represent essential pathways processes corticogenesis, neurogenesis, gliogenesis.","code":"\ncorticogenesis_sce <- corticogenesis.sce(directory = '~/Downloads')\nneurogenesis_sce <- neurogenesis.sce(directory = '~/Downloads')\ngliogenesis_sce <- gliogenesis.sce(directory = '~/Downloads')\n# select the path in which you have saved the objects!\ncorticogenesis_preferential_GO <- readRDS('~/Downloads/corticogenesis_preferential_GO.rds')\nneurogenesis_preferential_GO <- readRDS('~/Downloads/neurogenesis_preferential_GO.rds')\ngliogenesis_preferential_GO <- readRDS('~/Downloads/gliogenesis_preferential_GO.rds')\ncorticogenesis_pe_genes <- readRDS(\"~/Downloads/corticogenesis_subclass_preferential_genes.rds\")\nneurogenesis_pe_genes <- readRDS(\"~/Downloads/neurogenesis_subclass_preferential_genes.rds\")\ngliogenesis_pe_genes <- readRDS(\"~/Downloads/gliogenesis_subclass_preferential_genes.rds\")\ncorticogenesis_GO <- readRDS('~/Downloads/corticogenesis_GOBP_genesets.rds')\nneurogenesis_GO <- readRDS('~/Downloads/neurogenesis_GOBP_genesets.rds')"},{"path":"mapping-sc.html","id":"mapping-a-single-cell-rnaseq-dataset","chapter":"4 Mapping Single-cell data","heading":"4.2 Mapping a single cell RNAseq dataset","text":"","code":""},{"path":"mapping-sc.html","id":"data-preprocessing","chapter":"4 Mapping Single-cell data","heading":"4.2.1 Data preprocessing","text":"example dataset Kanton et al.Â (2019) (10.1038/s41586-019-1654-9) can downloaded : â€¦\nscope analyses, pre-processed data, removing low quality cells. also performed proportional random sampling ease following tutorial, total 10.000 cells. implies reduction total cell number keeping cell groups proportions.\nreproduce figures paper, used complete dataset, processed using ACTIONet pipeline clustering (see: https://compbio.mit.edu/ACTIONet/tutorials/intro.html. data processed using following functions default parameters: normalize.ace, reduce.ace, runACTIONet, clusterCells).Note: quality control needs done specifically dataset. assume cells following steps passed standard quality controls. can refer Seurat pipeline : https://satijalab.org/seurat/archive/v3.0/pbmc3k_tutorial.html scanpy one Python: https://scanpy.readthedocs.io/en/stable/tutorials/basics/clustering.html.report detailed pipeline standard Seurat steps required obtain clusters, needed following analyses. possible customize parameters pipeline, tuned specific dataset.can visualize UMAP clusters:\nFigure 4.1: Single-cell dataset UMAP clusters.\nSince dataset contains cells different stages, can also check stages distribution map information single cells:\nFigure 4.2: Single-cell dataset UMAP colored stage.\n","code":"\next_count_matrix <- readRDS('~/Downloads/sc_count_matrix.rds')\n# The pre-processing steps are done following the standard Seurat pipeline:\nlibrary(Seurat)\n\nsc_seu <- CreateSeuratObject(counts = ext_count_matrix)\nsc_seu <- NormalizeData(object = sc_seu)\nsc_seu <- FindVariableFeatures(object = sc_seu, span = 0.3)\nsc_seu <- ScaleData(object = sc_seu, features = VariableFeatures(sc_seu))\nnumPCs <- min(50, ncol(ext_count_matrix) - 1)\nsc_seu <- RunPCA(object = sc_seu, features = VariableFeatures(sc_seu), npcs = numPCs, approx = FALSE)\n\nPCs_to_use <- (sc_seu$pca@stdev)^2\nPCs_to_use <- PCs_to_use/sum(PCs_to_use)\nPCs_to_use <- cumsum(PCs_to_use)\nPCs_to_use <- min(which(PCs_to_use >= 0.75))\n\nPCs_to_use <- min(numPCs, PCs_to_use)\n\nsc_seu <- FindNeighbors(object = sc_seu, dims = seq_len(PCs_to_use))\nsc_seu <- FindClusters(object = sc_seu, resolution = 1, algorithm = 4, random.seed = 1) # if this gives an error, try setting algorithm to 1 or check ?FindClusters\n\nsc_seu <- RunUMAP(sc_seu, dims = seq_len(PCs_to_use))\nDimPlot(sc_seu, \n        reduction = \"umap\", \n        label = TRUE)\nstage_annotation <- unlist(lapply(strsplit(colnames(sc_seu), '.', fixed = TRUE), function(i) {i[2]}))\nnames(stage_annotation) <- Cells(sc_seu)\n\nsc_seu$stage <- stage_annotation\n\nstages_palette <- viridis(n = length(unique(stage_annotation)))\nnames(stages_palette) <- unique(stage_annotation)\n\nDimPlot(\n  sc_seu, \n  group.by = \"stage\",\n  reduction = \"umap\",\n  cols = stages_palette\n)"},{"path":"mapping-sc.html","id":"data-summary","chapter":"4 Mapping Single-cell data","heading":"4.2.2 Data summary","text":"standard mapping procedure requires definition summary transcriptional profiles cluster, can obtained two ways:Pseudobulk profiles (obtained summing counts cluster together normalizing using Counts Per Million (CPM)).Expression signatures (obtained averaging normalized counts cells cluster subtracting mean expression across cells).Depending type question, user can choose suitable summary profile. key distinction lies type information captured: signatures represent relative expression, describing given cluster differs others thus highlighting differences. contrast, pseudobulk profiles capture absolute expression levels therefore suitable biological interpretation without emphasizing relative changes. Signatures suited used relatively homogeneous dataset, greatly enhance subtle differences may just depicts noise.\nfollowing example use pseudobulk profiles, straightforward approach.Pseudobulk profiles can computed using following function, save SingleCellExperiment object pseudobulk counts counts log-normalized counts per millions logcounts:now define pseudobulks clusters obtained following Seurat pipeline:","code":"\nget_pseudobulk <- function(exp_matrix, membership_vector) { #the membership vector represents the group by which we want to compute pseudobulk, in our case cluster labels\n  unique_mv <- sort(names(which(table(membership_vector)>1))) \n  pseudo_counts <- t(DelayedArray::rowsum(t(exp_matrix), membership_vector))\n  rownames(pseudo_counts) <- rownames(exp_matrix)\n  norm_counts <- log2((t(t(pseudo_counts)/Matrix::colSums(pseudo_counts, na.rm = T))*1000000) + 1) #cpm normalization\n  \n  out <- SingleCellExperiment::SingleCellExperiment(assays=list(counts=pseudo_counts, \n                                                                logcounts=norm_counts))\n  if(is.null(colnames(out))) {\n    colnames(out) <- colnames(pseudo_counts)\n    }\n  out@metadata$cell_count <- table(membership_vector)\n  return(out)\n\n}\nsc_pseudo <- get_pseudobulk(exp_matrix = sc_seu@assays$RNA$counts, \n                            membership_vector = sc_seu$seurat_clusters)\ncolnames(sc_pseudo) <- paste0('c', colnames(sc_pseudo)) #to have strings and not numbers"},{"path":"mapping-sc.html","id":"mapping-on-the-reference-network","chapter":"4 Mapping Single-cell data","heading":"4.2.3 Mapping on the reference network","text":"Now comes actual mapping part, can easily performed using mapNetwork function, requires following main inputs:net: reference network usenew_profiles: transcriptional profiles map (either pseudobulk signatures)useful inputs can checked function help (?mapNetwork).Since original paper mention presence glial cell types, inhibitory excitatory neurons, reasonable map corticogenesis network. experimental design already defines presence glial cells excitatory neurons (respective precursors), suggested map neurogenesis gliogenesis steps.\nAnother approach first map general corticogenesis network map precise lineage-specific networks, also subset cells.can now visualize network mapped clusters top:\nFigure 4.3: Corticogenesis network mapped clusters.\nNewly mapped clusters locate close similar reference clusters, possible observe similar subclasses mapped cluster.\nvisualizing mapped network, can already appreciate clusters generally map two different sections network, one close radial glia cycling radial glia, close immature neurons. quantify similarity, developed score per subclass per cluster, using 15 similar reference clustersâ€™ annotations (number reference clusters use can set changing n_nearest mapNetwork function).\nscore sums 1 represents weighted fraction clusters neighborhood belonging different subclasses.\nscore can visualized barplot reporting y-axis proportions (0-1) different subclasses, x-axis mapped clusters.\nFigure 4.4: Annotation scores across clusters.\nget single label mapped cluster, take maximum scores. depicts similar subclass among closest neighbors.quantification can obtained stages maturation, either specifying color_attr = 'Stages' mapNetwork function, running annotateMapping function, requires following inputs:net: reference network use.new_cor: correlation mapped points reference clusters, can found mapped_object$new_cor.color_attr: annotation label use, case â€˜Stagesâ€™.mapping strategy allows mapping expression matrix, thus added quantification mapping confidence, described two diverse measures:local score (mapped_object$annotation$Mapping.Confidence) mapped point, showing average 15 highest correlation values mapped point reference clusters.local score (mapped_object$annotation$Mapping.Confidence) mapped point, showing average 15 highest correlation values mapped point reference clusters.global score (mapped_object$annotation$Global.Confidence), describing average confidence among mapped point.global score (mapped_object$annotation$Global.Confidence), describing average confidence among mapped point.confidence values can accessed following way:confidence score tells similar mapped points neighboring clusters, also can help identifying profiles low quality cell types represented resource.example, cluster 23 slightly lower confidence score (~0.50) compared others, may worth checking quality cells cluster (done ), assess whether low quality group cells.Sometimes clusters high confidence score, nieghbors different annotations, making hard actually infer single annotation. help , possible apply confidence score inferred annotations defined :","code":"\nmapped_sc_pseudo <- mapNetwork(net = corticogenesis_sce, \n                               new_profiles = logcounts(sc_pseudo))\nmapped_sc_pseudo$new_plot\nmapped_sc_pseudo$annotation$Barplot\nmapped_sc_pseudo$annotation$Best.Annotation\n#>      c1      c2      c3      c4      c5      c6      c7 \n#>   \"eIN\"  \"miEN\"   \"eIN\"   \"cRG\"    \"RG\"  \"miEN\"   \"cRG\" \n#>      c8      c9     c10     c11     c12     c13     c14 \n#>  \"miEN\"   \"eIN\"    \"RG\"   \"eIN\"   \"cRG\"   \"cRG\"    \"RG\" \n#>     c15     c16     c17     c18     c19     c20     c21 \n#>    \"RG\" \"imNIT\" \"imNIT\"    \"RG\"    \"RG\"    \"RG\"   \"cRG\" \n#>     c22     c23 \n#>   \"eIN\"    \"RG\"\n# per cluster confidence\nmapped_sc_pseudo$annotation$Mapping.Confidence\n#>        c1        c2        c3        c4        c5        c6 \n#> 0.7130546 0.7547882 0.6901726 0.8477842 0.7965150 0.7947670 \n#>        c7        c8        c9       c10       c11       c12 \n#> 0.6281157 0.7647813 0.7314415 0.7639241 0.7194806 0.6995298 \n#>       c13       c14       c15       c16       c17       c18 \n#> 0.6288900 0.7215679 0.8474292 0.7706888 0.7342306 0.8037366 \n#>       c19       c20       c21       c22       c23 \n#> 0.6317051 0.7253773 0.5659153 0.6400742 0.5006500\n\n# global confidence\nmapped_sc_pseudo$annotation$Global.Confidence\n#> [1] 0.7162878\n# checking the annotation confidence of the first five clusters \nmapped_sc_pseudo$annotation$Annotations.Confidence[seq(1,5)]\n#> $c1\n#>        eIN       miEN \n#> 0.61520448 0.09785007 \n#> \n#> $c2\n#>      miEN     imNIT \n#> 0.6538900 0.1008981 \n#> \n#> $c3\n#>        eIN      imNIT \n#> 0.64261159 0.04756101 \n#> \n#> $c4\n#>       cRG        RG \n#> 0.5631011 0.2846830 \n#> \n#> $c5\n#>         RG        cRG \n#> 0.74243175 0.05408324"},{"path":"mapping-sc.html","id":"knwoledge-transfer","chapter":"4 Mapping Single-cell data","heading":"4.2.4 Knwoledge transfer","text":"annotations newly defined can now transferred original dataset visualized single cell level.\nFigure 4.5: Single-cell dataset UMAP clusters annotations.\nlooking UMAP labelled cluster together newly annotated UMAP, can appreciate cells annotated cRG close cells annotated RG indeed cluster 4, cluster similar annotation values cRG RG.validate annotation, can also visualize preferentially expressed genes relevant subclasses:\nFigure 4.6: Preferential genes expression\nexpression preferentially expressed genes defined resource match expectations, cluster 4 high expression cRG markers, confirming annotations given mapping strategy.\ncharacterize clusters, can leverage list manually curate Gene Ontology Biological Processes assess expression levels.\nFirst, compute average expression gene sets:, can visualize relative expression Heatmap assess biological processes charachterize mapped clusters.\nFigure 4.7: Heatmap corticogenesis-specific GO biological processes resource mapped clusters.\nheatmap shows generally biological processes match annotations, radial glia clusters displaying higher expression processes associated proliferation glial metabolism, can also see clusters 19 23 show high expression stress-related processes, displaying low expression terms related radial glia, assigned annotation. explain cluster 23 low mapping confidence suggest clusters composed early stressed cells.\nFigure 4.8: Heatmap neurogenesis-specific GO biological processes resource mapped clusters.\n, cluster highest neuroinflammatory response (indicative stress) cluster 23.\nThanks use neurogenesis-specific network can appreciate neuronal specific processes expressed clusters assigned immature neuron annotations labelled progenitors.Additionally, can visualize mapped points directly eTraces, see similar clusters resource network based gene expression.\nfunction perform analysis map_eTrace, requires following inputs:net: reference network usemapped_obj: result mapNetworkthe inputs required run plot_eTrace (see Chapter 3)\nFigure 4.9: VIM SYT1 eTrace corticogenesis mapped points\ntype analysis can clearly appreciate distinction radial glia-like clusters neuronal ones. Additionally, can see glance mapped points resemble mature reference clusters, age increases left right. rightward clusters : 2, 9, 11, 14.\ncheck percentage cells belonging latest time point (4 months) across cluster,\ncan see clusters also highest proportion latest-stage cells:can also obtain markers cluster using Seurat function FindAllMarkers plot genes eTraces.\nFigure 4.10: eTraces markers selected clusters.\n, easy distinguish neuronal clusters radial glia-like clusters, also can find clusters inhibitory neurons-like (e.g.Â clusters 22 11), cluster 23 markers highly expressed microglia , pointing possible transcriptional signature stress-related.","code":"\nnew_annotation <- mapped_sc_pseudo$annotation$Best.Annotation[paste0('c', sc_seu$seurat_clusters)]\nnames(new_annotation) <- Cells(sc_seu)\n\nsc_seu$annotation <- new_annotation\n\ncorticogenesis_palette <- unique(corticogenesis_sce$SubClass_color)\nnames(corticogenesis_palette) <- unique(corticogenesis_sce$SubClass)\n\n\nDimPlot(\n  sc_seu, \n  reduction = \"umap\",\n  label = TRUE, \n) + \n  ggtitle(\"clusters\") +\n  theme(plot.title = element_text(hjust = 0.5))\n\nDimPlot(\n  sc_seu, \n  group.by = \"annotation\",\n  reduction = \"umap\",\n  cols = corticogenesis_palette,\n  label = TRUE,\n) + \n  ggtitle(\"annotation\") +\n  theme(plot.title = element_text(hjust = 0.5))\nsc_seu$eIN.Score <- Matrix::colMeans(\n  GetAssayData(sc_seu, slot = \"data\")[corticogenesis_pe_genes$eIN[which(corticogenesis_pe_genes$eIN %in% rownames(sc_seu))],])\n\n\nsc_seu$cRG.Score <- Matrix::colMeans(\n  GetAssayData(sc_seu, slot = \"data\")[corticogenesis_pe_genes$cRG[which(corticogenesis_pe_genes$cRG %in% rownames(sc_seu))],])\n\n\nsc_seu$RG.Score <- Matrix::colMeans(\n  GetAssayData(sc_seu, slot = \"data\")[corticogenesis_pe_genes$RG[which(corticogenesis_pe_genes$RG %in% rownames(sc_seu))],])\n\n\nsc_seu$imNIT.Score <- Matrix::colMeans(\n  GetAssayData(sc_seu, slot = \"data\")[corticogenesis_pe_genes$imNIT[which(corticogenesis_pe_genes$imNIT %in% rownames(sc_seu))],])\n\n\nsc_seu$miEN.Score <- Matrix::colMeans(\n  GetAssayData(sc_seu, slot = \"data\")[corticogenesis_pe_genes$miEN[which(corticogenesis_pe_genes$miEN %in% rownames(sc_seu))],])\nFeaturePlot(sc_seu, \n            features = \"eIN.Score\", \n            reduction = \"umap\") + ggtitle(\"eIN\")\nFeaturePlot(sc_seu, \n            features = \"cRG.Score\", \n            reduction = \"umap\") + ggtitle(\"cRG\")\nFeaturePlot(sc_seu, \n            features = \"RG.Score\", \n            reduction = \"umap\") + ggtitle(\"RG\")\nFeaturePlot(sc_seu, \n            features = \"imNIT.Score\", \n            reduction = \"umap\") + ggtitle(\"imNIT\")\nFeaturePlot(sc_seu, \n            features = \"miEN.Score\", \n            reduction = \"umap\") + ggtitle(\"miEN\")\nDimPlot(\n  sc_seu, \n  reduction = \"umap\",\n  group.by = \"annotation\",\n  cols = corticogenesis_palette,\n  label = TRUE, \n) + \n  ggtitle(\"annotation\") +\n  theme(plot.title = element_text(hjust = 0.5))\nsc_seu_cortico_GOBP <- do.call(rbind, lapply(corticogenesis_GO, function(g) {\n  \n  g <- g[which(g %in% rownames(sc_seu))]\n  \n  Matrix::colMeans(logcounts(sc_pseudo)[g,])\n  \n}))\n\nrownames(sc_seu_cortico_GOBP) <- gsub(\" \\\\(GO:[0-9]+\\\\)$\", \"\", rownames(sc_seu_cortico_GOBP)) #to simplify the gene sets names\n\nsc_seu_cortico_GOBP <- sc_seu_cortico_GOBP[,mixedorder(colnames(sc_seu_cortico_GOBP))] #to put them in alphabetical order\n#this annotation replicates the one in Figure .. and aggregates cell types in major groups\ncortico_subclass_groups <- colnames(corticogenesis_preferential_GO$GO_Biological_Process_2025$preferential)\ncortico_subclass_groups[which(cortico_subclass_groups %in% c('L23IT', 'L35IT', 'L6IT', 'L6NIT'))] <- 'matEN'\ncortico_subclass_groups[which(cortico_subclass_groups %in% c('LAMP5', 'SST', 'PVALB', 'VIP'))] <- 'matIN'\ncortico_subclass_groups[which(cortico_subclass_groups %in% c('imIT', 'imNIT', 'eEN', 'miEN'))] <- 'immEN'\ncortico_subclass_groups[which(cortico_subclass_groups %in% c('eIN', 'imIN'))] <- 'immIN'\ncortico_subclass_groups[which(cortico_subclass_groups %in% c('Opc', 'Oligo', 'Astro'))] <- 'maGlia'\ncortico_subclass_groups[which(cortico_subclass_groups %in% c('Micro'))] <- 'miGlia'\ncortico_subclass_groups[which(cortico_subclass_groups %in% c('RG', 'cRG', 'IPC'))] <- 'Prog'\n\ncortico_subclass_groups <- factor(cortico_subclass_groups, \n                                  levels = c('Prog', 'immEN', 'immIN', 'matEN', 'matIN', 'maGlia', 'miGlia')) \n\ncortico_gobp_groups <- factor(c(rep('Astro', 4), rep('Oligo', 3), rep('Opc', 3), rep('OligoGlia', 2), rep('matEN', 4), rep('matIN', 4), rep('immEN', 4), rep('Micro', 4), rep('Prog', 4), rep('Stress', 4)), levels = c('Prog', 'immEN', 'matEN', 'matIN', 'Opc', 'Oligo', 'OligoGlia', 'Astro', 'Micro', 'Stress'))\n\ncortico_gobp_pe <- corticogenesis_preferential_GO$GO_Biological_Process_2025$preferential[names(corticogenesis_GO),]\n\nrownames(cortico_gobp_pe) <- gsub(\" \\\\(GO:[0-9]+\\\\)$\", \"\", rownames(cortico_gobp_pe))\nht1 <- Heatmap(\n  cortico_gobp_pe,\n  name = 'preferential\\nexpression',\n  width = unit(ncol(cortico_gobp_pe) * 4.2, 'mm'), #4.2, 18,8\n  height = unit(nrow(cortico_gobp_pe) * 4.2, 'mm'),\n  show_row_dend = FALSE,\n  show_column_dend = FALSE,\n  row_title_rot = 0,\n  row_names_gp = gpar(fontsize = 9),\n  column_title_rot = 90,\n  column_split = cortico_subclass_groups,\n  cluster_column_slices = FALSE,\n  row_split = cortico_gobp_groups,\n  cluster_row_slices = FALSE,\n  column_title_gp = gpar(fontsize = 0)\n)\n\nht2 <- Heatmap(\n  t(scale(t(sc_seu_cortico_GOBP))),\n  name = 'scaled\\nexpression',\n  width = unit(ncol(sc_seu_cortico_GOBP) * 4.2, 'mm'),\n  cluster_columns = TRUE, \n  row_names_gp = gpar(fontsize = 9),\n  right_annotation = rowAnnotation(max = anno_barplot(apply(sc_seu_cortico_GOBP, 1, max), \n                                                      gp = gpar(fill = 'black')), \n                                   annotation_name_side = 'top', \n                                   annotation_name_rot = 0), \n  bottom_annotation = HeatmapAnnotation(annotation = mapped_sc_pseudo$annotation$Best.Annotation[colnames(sc_seu_cortico_GOBP)], \n                      col = list(annotation = corticogenesis_palette), \n                      show_legend = FALSE,\n                      show_annotation_name = FALSE), \n  show_column_dend = FALSE,\n)\n\nht_list <- ht1 + ht2\ndraw(ht_list, heatmap_legend_side = \"left\")\nsc_seu_neuro_GOBP <- do.call(rbind, lapply(neurogenesis_GO, function(g) {\n  \n  g <- g[which(g %in% rownames(sc_seu))]\n  \n  Matrix::colMeans(logcounts(sc_pseudo)[g,])\n  \n}))\n\nrownames(sc_seu_neuro_GOBP) <- gsub(\" \\\\(GO:[0-9]+\\\\)$\", \"\", rownames(sc_seu_neuro_GOBP))\nsc_seu_neuro_GOBP <- sc_seu_neuro_GOBP[,mixedorder(colnames(sc_seu_neuro_GOBP))]\n\n\nneuro_gobp_pe <- neurogenesis_preferential_GO$GO_Biological_Process_2025$activity[names(neurogenesis_GO),]\n\n\nneuroTrends <- do.call(cbind, lapply(rownames(neuro_gobp_pe), function(i)\n  smooth.spline(1:length(neuro_gobp_pe[i,]), \n                neuro_gobp_pe[i,], spar = 1)$y))\n\ncolnames(neuroTrends) <- rownames(neuro_gobp_pe)\n\nneuroTrends <- t(neuroTrends)[names(neurogenesis_GO),]\nneuroTrends <- neuroTrends[order(apply(neuroTrends, 1, which.max), Matrix::rowMeans(neuroTrends)),]\n\nrownames(neuroTrends) <- gsub(\" \\\\(GO:[0-9]+\\\\)$\", \"\", rownames(neuroTrends))\n\nstage_palette <- unique(neurogenesis_sce$Stages_color)\nnames(stage_palette) <- unique(neurogenesis_sce$Stages)\n\nh1 <- Heatmap(t(scale(t(neuroTrends))), \n              cluster_columns = F, \n              cluster_rows = F,\n              bottom_annotation = HeatmapAnnotation(df=data.frame(stage=neurogenesis_sce$Stages), \n                                                    col=list(stage=stage_palette), \n                                                    show_legend = F, \n                                                    show_annotation_name = F), \n              name = 'inferred expression\\n(z scaled)', \n              height = unit(100, 'mm'), \n              width = unit(30, 'mm'))\n\nht2 <- Heatmap(\n  t(scale(t(sc_seu_neuro_GOBP[rownames(neuroTrends),]))),\n  name = 'scaled\\nexpression',\n  width = unit(ncol(sc_seu_neuro_GOBP) * 4.2, 'mm'),\n  cluster_columns = TRUE, \n  row_names_gp = gpar(fontsize = 9,\n                      fontface =ifelse(colnames(t(scale(t(sc_seu_neuro_GOBP[rownames(neuroTrends),])))) %in% c(\"c23\"), \"bold\", \"plain\")), \n  right_annotation = rowAnnotation(max = anno_barplot(apply(sc_seu_neuro_GOBP[rownames(neuroTrends),], 1, max), \n                                                      gp = gpar(fill = 'black')),\n                                   annotation_name_side = 'top',\n                                   annotation_name_rot = 0), \n  bottom_annotation = HeatmapAnnotation(annotation = mapped_sc_pseudo$annotation$Best.Annotation[colnames(sc_seu_cortico_GOBP)], \n                                        col = list(annotation = corticogenesis_palette), \n                                        show_legend = FALSE,\n                                        show_annotation_name = FALSE), \n  show_column_dend = FALSE\n)\n\n\n\nht_list <- h1 + ht2\n\ndraw(ht_list, heatmap_legend_side = \"left\")\nmap_eTrace(net = corticogenesis_sce, \n         mapped_obj = mapped_sc_pseudo, \n         genes = 'VIM',\n         main = \"VIM\")\nmap_eTrace(net = corticogenesis_sce, \n         mapped_obj = mapped_sc_pseudo, \n         genes = 'SYT1',\n         main = \"SYT1\")\nsort(apply(table(sc_seu$stage, paste0('c', sc_seu$seurat_clusters)), 2, function(i) {i/sum(i)})['Organoid-4M',]*100)\n#>        c12        c13        c17        c20        c21 \n#>  0.0000000  0.0000000  0.0000000  0.0000000  0.0000000 \n#>        c22         c7        c16        c18        c10 \n#>  0.0000000  0.0000000  0.2590674  0.2857143  0.8968610 \n#>         c8         c3         c6         c5        c15 \n#>  1.2219959  1.3736264  3.2374101  4.3478261  8.7281796 \n#>        c19         c4         c1        c23         c2 \n#>  9.7826087 10.3395062 11.1006585 11.7647059 42.8571429 \n#>        c14        c11         c9 \n#> 44.0097800 47.1655329 53.0303030\nmarkers <- FindAllMarkers(sc_seu, \n                          only.pos = TRUE, \n                          min.pct = 0.5, \n                          logfc.threshold = 1)\n\nmarkers <- markers[which(markers$p_val_adj < 0.001),]\n\nmarkers <- split(markers$gene, markers$cluster)\nlapply(names(markers), function(i) {\n        g <- markers[[i]]\n        g <- g[which(g %in% rownames(corticogenesis_sce))]\n        plot_eTrace(net = corticogenesis_sce, \n                    genes = g, \n                    main = paste(\"markers of cluster\",i))\n})"},{"path":"mapping-bulk.html","id":"mapping-bulk","chapter":"5 Mapping Bulk data","heading":"5 Mapping Bulk data","text":"","code":""},{"path":"mapping-bulk.html","id":"loading-necessary-libraries-and-data-3","chapter":"5 Mapping Bulk data","heading":"5.1 Loading necessary libraries and data","text":"","code":""},{"path":"mapping-bulk.html","id":"loading-the-right-libraries-3","chapter":"5 Mapping Bulk data","heading":"5.1.1 Loading the right libraries","text":"","code":"\n# functions package\nlibrary(neuRoDev)\n# extra packages\nlibrary(ComplexHeatmap)\nlibrary(gtools)\nlibrary(edgeR)"},{"path":"mapping-bulk.html","id":"loading-the-networks-necessary-objects-3","chapter":"5 Mapping Bulk data","heading":"5.1.2 Loading the networks necessary objects","text":"Load preferential expression Gene Ontology Biological Processes (BP), Molecular Functions (MF), Cellular Components (CC). objects available . object list containing preferential expression scores one three reference networks three ontologies (BP, MF, CC). element list contains activity (activity) derived Gene Set Variation Analysis (one value per gene set cluster) preferential expression scores (preferential; one value per gene set subclass).\ngene set enrichment values can found files corticogenesis_preferentialEnrichR, neurogenesis_preferentialEnrichR, gliogenesis_preferentialEnrichR.Load preferentially expressed gene list. objects available : â€¦Load manually curated Gene Ontology Biological Processes corticogenesis neurogenesis networks, available .","code":"\ncorticogenesis_sce <- corticogenesis.sce(directory = '~/Downloads')\nneurogenesis_sce <- neurogenesis.sce(directory = '~/Downloads')\ngliogenesis_sce <- gliogenesis.sce(directory = '~/Downloads')\n# select the path in which you have saved them\ncorticogenesis_preferential_GO <- readRDS('~/Downloads/corticogenesis_preferential_GO.rds')\nneurogenesis_preferential_GO <- readRDS('~/Downloads/neurogenesis_preferential_GO.rds')\ngliogenesis_preferential_GO <- readRDS('~/Downloads/gliogenesis_preferential_GO.rds')\ncorticogenesis_pe_genes <- readRDS(\"~/Downloads/corticogenesis_subclass_preferential_genes.rds\")\nneurogenesis_pe_genes <- readRDS(\"~/Downloads/neurogenesis_subclass_preferential_genes.rds\")\ngliogenesis_pe_genes <- readRDS(\"~/Downloads/gliogenesis_subclass_preferential_genes.rds\")\ncorticogenesis_GO <- readRDS('~/Downloads/corticogenesis_GOBP_genesets.rds')\nneurogenesis_GO <- readRDS('~/Downloads/neurogenesis_GOBP_genesets.rds')"},{"path":"mapping-bulk.html","id":"mapping-a-bulk-cell-rnaseq-dataset","chapter":"5 Mapping Bulk data","heading":"5.2 Mapping a bulk cell RNAseq dataset","text":"example dataset Gordon et al.Â (2021) can downloaded : â€¦\ndataset contains bulk RNAseq expression organoid samples different time points. scope analyses, pre-processed data, removing batch-effect using package sva, computed Counts Per Million (CPM) (log-normalized, saved logcounts). Pre-processing steps can done differently depending dataset characteristics, following steps shown tutorial apply bulk RNAseq samples. lack correct pre-processing steps may affect results interpretation following analyses.average samples differentiation day. interested variability replicates, step can avoided.Differently scRNAseq dataset mapping (see @ref(4.1-Mapping_scRNAseq)), bulk RNAseq datasets donâ€™t need processing transcriptional profiles, already represent pool cells sequenced together. Hence, bulk samples can directly mapped using mapNetwork function, requires following main inputs:net: reference network usenew_profiles: transcriptomic profiles mapOther useful inputs can checked ?mapNetworkWe can now visualize network mapped clusters top:\nFigure 5.1: Corticogenesis network mapped samples.\nvisualization, can already appreciate samples early days (d25, d50) map close radial glia clusters, moving towards immature neurons days 75, 100 150.\nNevertheless, day 200 can see unexpected transcriptional switch samples return map closer radial glia. mean either somehow went back undifferentiated state, start looking like mature glia (astrocytes particular, similar radial glia, also biologically). investigate deep differences, possible leverage analyses tools described .Since newly mapped samples locate close similar reference clusters, possible qualitatively understand similar subclass mapped point. quantify similarity, developed score per subclass per mapped sample, using 15 similar reference clustersâ€™ annotations (number reference clusters use can set changing n_nearest mapNetwork function). score can visualized :\nFigure 5.2: Annotation scores across samples\nDays 250, 300 400 small resemblance astrocytes, lost days 500 600.get single label mapped cluster, take maximum scores.\ndepicts similar subclass among closest neighbors.quantification can done stages instead subclasses, either specifying color_attr = 'Stages' mapNetwork function, running annotateMapping function, requires following inputs:net: reference network use.new_cor: correlation mapped points reference clusters, can found mapped_object$new_cor.color_attr: annotation label use, case â€˜Stagesâ€™.mapping strategy allows mapping expression matrix, thus added quantification mapping confidence, described two diverse measures:local score (mapped_object$annotation$Mapping.Confidence) mapped point, showing average 15 highest correlation values mapped point reference clusters.local score (mapped_object$annotation$Mapping.Confidence) mapped point, showing average 15 highest correlation values mapped point reference clusters.global score (mapped_object$annotation$Global.Confidence), describing average confidence among mapped point.global score (mapped_object$annotation$Global.Confidence), describing average confidence among mapped point.confidence values can accessed following way:can see generally mapped samples relatively high confidence, decreases last days compared first.analysis mapping samples directly eTraces, see similar clusters express less certain genes.\nfunction perform analysis map_eTrace, requires following inputs:net: reference network use.mapped_obj: result mapNetwork.inputs required run plot_eTrace (see Chapter 3).\nFigure 5.3: Preferential genes eTrace corticogenesis mapped points.\neTrace radial glia markers describes pattern shown looking mapping network: mapped points form circle early time points late ones, goes back showing resemblance early radial glia clusters. indicates look similar radial glia neurons, also look similar early radial glia compared late ones.\nlooking instead eTrace immature excitatory neuron markers, can see samples d75 d200 average line (d200 lowest), pointing fact time points show similarity immature neurons. plotting instead eTrace mature neurons, sample shows particularly high values, suggesting organoids recapitulate full maturity described vivo samples. Lastly, eTrace astrocyte markers shows days 250 400 indeed higher samples (also late radial glia clusters show relatively high values), clearly days 500 600 much lower.can additionally check expression preferentially expressed genes defined within resource mapped samples. show function , included package (keep main functions). function plotTrends requires following inputs:net: reference network use.pref_exp_genes: preferentially expressed genes list.sce: external object form SingleCellExperiment object,profiles: actual expression matrix used mapping.coldata: find information replicates used averaging.subclass: indicated vector selects subset reference subclasses. Defaults subclasses.ylim: lower upper limits y-axis (defaults NULL, goes back automatic R plot ylim).together: defines different preferentially expressed genes plotted together (adjust ylim accordingly) (defaults FALSE).relative: TRUE, expression scaled 0 1 (defaults FALSE).\nFigure 5.4: Preferential genes astrocytes cycling radial glia expression mapped data points.\nAstrocyte markers increase day 400, decrease overcome cycling radial glia markers time points (d500, d600).consistent expression levels GO processes manually curated compendium.assess expression levels processes, first obtain average expression gene sets mapped data:\nFigure 5.5: Heatmap corticogenesis-specific GO biological processes resource mapped samples.\nheatmap can see radial glia biological processes highly expressed first 2-3 time points, also last two. , together high expression stress-related processes (increases time progresses) suggests indeed last days stressed rather similar astrocytes. Also neuronal processes start around day 75, decrease around days 300-400.type analysis can done neurogenesis network:\nFigure 5.6: Heatmap neuroogenesis-specific GO biological processes resource mapped samples.\ncan see neuroinflammatory response regulation increases time, well regulation neuron apoptotic process.Another approach confirm findings obtain markers cluster using Seurat function FindAllMarkers plot genes eTraces.\nFigure 5.7: eTrace sample-specific differential genes corticogenesis.\nanalysis can appreciate genes differentially expressed different samples expressed reference. can appreciate genes differentially expressed organoids early time points decrease expression time, particularly day 25.\nday 75 day 200 notice differentially expressed genes mainly neuronal, particular day 200, highly expressed immature neurons, decreasing along maturation. Interestingly, differentially expressed genes days 300 400 indeed expressed astrocytes increase time, specific day 600 higher radial glia cells microglia, usually hints stress response (! microglia shouldnâ€™t populate organoids).","code":"\nbulk_sce <- readRDS('~/Downloads/bulk_sce.rds')\nbulk_average <- neuRoDev:::get_column_group_average(logcounts(bulk_sce), \n                                                    bulk_sce$`differentiation day`)\nmapped_bulk <- mapNetwork(net = corticogenesis_sce, \n                          new_profiles = bulk_average)\nmapped_bulk$new_plot\nmapped_bulk$annotation$Barplot\nmapped_bulk$annotation$Best.Annotation\n#>     d25     d50     d75    d100    d150    d200    d250 \n#>    \"RG\"    \"RG\" \"imNIT\" \"imNIT\" \"imNIT\"    \"RG\"    \"RG\" \n#>    d300    d400    d500    d600 \n#>    \"RG\"    \"RG\"    \"RG\"    \"RG\"\n# global confidence\nmapped_bulk$annotation$Global.Confidence\n#> [1] 0.6783803\n\n# per cluster confidence\nmapped_bulk$annotation$Mapping.Confidence\n#>       d25       d50       d75      d100      d150      d200 \n#> 0.7468790 0.7425336 0.7363235 0.7106007 0.6891449 0.6729147 \n#>      d250      d300      d400      d500      d600 \n#> 0.6236117 0.6462351 0.6386074 0.6045623 0.6507705\nmap_eTrace(net = corticogenesis_sce, \n           mapped_obj = mapped_bulk, \n           genes = corticogenesis_pe_genes$RG, \n           main = 'RG')\n\nmap_eTrace(net = corticogenesis_sce, \n           mapped_obj = mapped_bulk, \n           genes = corticogenesis_pe_genes$miEN.imNIT.eEN, \n           main = 'immEN')\n\nmap_eTrace(net = corticogenesis_sce, \n           mapped_obj = mapped_bulk, \n           genes = corticogenesis_pe_genes$L6IT.L6NIT.L35IT.L23IT.SST.VIP.PVALB.LAMP5, \n           main = 'matNEU')\n\nmap_eTrace(net = corticogenesis_sce, \n           mapped_obj = mapped_bulk, \n           genes = corticogenesis_pe_genes$Astro, \n           main = 'Astrocytes')\nplotTrends <- function(net, pref_exp_genes, sce, profiles, coldata, subclass = NULL, ylim = NULL, together = FALSE, relative = FALSE) {\n  \n  if(is.null(subclass)) {\n    subclass <- unique(net$SubClass)\n  }\n  \n  if(!together) {\n    lapply(subclass, function(i) {\n      g <- unlist(pref_exp_genes[names(pref_exp_genes) == i])\n      g <- g[g %in% rownames(profiles)]\n      if(length(g) < 2) {\n        return(NULL)\n      }\n      \n      y_means <- Matrix::colMeans(profiles[g, , drop = FALSE])\n      single_values <- Matrix::colMeans(logcounts(sce)[g,])\n      \n      if(relative) {\n        norm_factor <- max(y_means)\n      } else {\n        norm_factor <- 1\n      }\n      \n      y_means <- y_means/norm_factor\n      single_values <- single_values/norm_factor\n      \n      days <- colnames(profiles)\n      y_sds <- sapply(days, function(d) {\n        vals <- Matrix::colMeans(logcounts(sce)[g, colData(sce)[,coldata] == d, drop = FALSE])/norm_factor\n        sd(vals)\n      })\n      y_sds[which(is.na(y_sds))] <- 0\n      \n      ylim_range <- range(c(y_means - y_sds, y_means + y_sds))\n      ylim_range_two <- range(single_values)\n      ylim_range <- c(min(c(ylim_range[1], ylim_range_two[1])), max(c(ylim_range[2], ylim_range_two[2])))\n      if(!is.null(ylim)) {\n        ylim_range <- ylim\n      }\n      \n      plot(seq_along(y_means), y_means,\n           ylab = ifelse(relative, 'relative expression', 'expression'), xlab = '', xaxt = 'n',\n           type = 'l', lwd = 2,\n           col = net$SubClass_color[which(net$SubClass == i)][1],\n           main = i, ylim = ylim_range)\n      axis(side = 1, at = seq_along(y_means), labels = days, las = 2)\n      \n      x_vals <- seq_along(y_means)\n      upper <- y_means + y_sds\n      lower <- y_means - y_sds\n      polygon(c(x_vals, rev(x_vals)),\n              c(upper, rev(lower)),\n              col = adjustcolor(net$SubClass_color[which(net$SubClass == i)][1], alpha.f = 0.2),\n              border = NA)\n      \n      lines(x_vals, y_means, lwd = 2,\n            col = net$SubClass_color[which(net$SubClass == i)][1])\n      \n      for (j in seq_along(y_means)) {\n        d <- names(y_means)[j]\n        y_vals <- single_values[which(colData(sce)[,coldata] == d)]\n        x_jitter <- jitter(rep(j, length(y_vals)), amount = 0.1)\n        x_jitter[1] <- j\n        show_top <- length(x_jitter)-2\n        if(length(x_jitter) < 2) {\n          idxs <- seq(1,length(x_jitter))\n        } else {\n          idxs <- c(which.min(y_vals), which.max(y_vals), sample(seq(1,length(x_jitter)), show_top)) \n        }\n        x_jitter <- x_jitter[idxs]\n        y_vals <- y_vals[idxs]\n        points(x_jitter, y_vals, pch = 19, col = adjustcolor(net$SubClass_color[which(net$SubClass == i)][1], alpha.f = 0.5), cex = 0.5)\n      }\n      \n    }) \n  } else {\n    \n    days <- colnames(profiles)\n    \n    all_y_means <- lapply(subclass, function(i) {\n      g <- unlist(pref_exp_genes[names(pref_exp_genes) == i])\n      g <- g[g %in% rownames(profiles)]\n      if(length(g) < 2) {\n        return(NULL)\n      }\n      y_means <- Matrix::colMeans(profiles[g, , drop = FALSE])\n      single_values <- Matrix::colMeans(logcounts(sce)[g,])\n      \n      if(relative) {\n        norm_factor <- max(y_means)\n      } else {\n        norm_factor <- 1\n      }\n      \n      y_means <- y_means/norm_factor\n      single_values <- single_values/norm_factor\n      \n      y_sds <- sapply(days, function(d) {\n      vals <- Matrix::colMeans(logcounts(sce)[g, colData(sce)[,coldata] == d, drop = FALSE])/norm_factor\n        sd(vals)\n      })\n      y_sds[which(is.na(y_sds))] <- 0\n      return(c(y_means - y_sds, y_means + y_sds))\n      \n    })\n    \n    g <- unlist(pref_exp_genes[names(pref_exp_genes) == subclass[1]])\n    g <- g[g %in% rownames(profiles)]\n    if(length(g) < 2) {\n      return(NULL)\n    }\n    \n    y_means <- Matrix::colMeans(profiles[g, , drop = FALSE])\n    single_values <- colMeans(logcounts(sce)[g,])\n    \n    if(relative) {\n      norm_factor <- max(y_means)\n    } else {\n      norm_factor <- 1\n    }\n    \n    y_means <- y_means/norm_factor\n    single_values <- single_values/norm_factor\n      \n    days <- colnames(profiles)\n    y_sds <- sapply(days, function(d) {\n      vals <- Matrix::colMeans(logcounts(sce)[g, colData(sce)[,coldata] == d, drop = FALSE])/norm_factor\n      sd(vals)\n    })\n    y_sds[which(is.na(y_sds))] <- 0\n    \n    ylim_range <- range(c(y_means - y_sds, y_means + y_sds))\n    ylim_range_two <- range(single_values)\n    ylim_range <- c(min(c(ylim_range[1], ylim_range_two[1])), max(c(ylim_range[2], ylim_range_two[2])))\n    if(!is.null(ylim)) {\n      ylim_range <- ylim\n    }\n    \n    plot(seq_along(y_means), y_means,\n         ylab = ifelse(relative, 'relative expression', 'expression'), xlab = '', xaxt = 'n',\n         type = 'l', lwd = 2,\n         col = net$SubClass_color[which(net$SubClass == subclass[1])][1],\n         main = paste0(subclass, collapse = '-'), ylim = ylim_range)\n    axis(side = 1, at = seq_along(y_means), labels = days, las = 2)\n    \n    x_vals <- seq_along(y_means)\n    upper <- y_means + y_sds\n    lower <- y_means - y_sds\n    polygon(c(x_vals, rev(x_vals)),\n            c(upper, rev(lower)),\n            col = adjustcolor(net$SubClass_color[which(net$SubClass == subclass[1])][1], alpha.f = 0.2),\n            border = NA)\n    \n    lines(x_vals, y_means, lwd = 2,\n          col = net$SubClass_color[which(net$SubClass == subclass[1])][1])\n    \n    for (j in seq_along(y_means)) {\n      d <- names(y_means)[j]\n      y_vals <- single_values[which(colData(sce)[,coldata] == d)]\n      x_jitter <- jitter(rep(j, length(y_vals)), amount = 0.1)\n      x_jitter[1] <- j\n      show_top <- length(x_jitter)-2\n      if(length(x_jitter) < 2) {\n        idxs <- seq(1,length(x_jitter))\n      } else {\n        idxs <- c(which.min(y_vals), which.max(y_vals), sample(seq(1,length(x_jitter)), show_top)) \n      }\n      x_jitter <- x_jitter[idxs]\n      y_vals <- y_vals[idxs]\n      points(x_jitter, y_vals, pch = 19, col = adjustcolor(net$SubClass_color[which(net$SubClass == subclass[1])][1], alpha.f = 0.5), cex = 0.5)\n    }\n    \n    for(i in subclass[seq(2,length(subclass))]) {\n      g <- unlist(pref_exp_genes[names(pref_exp_genes) == i])\n      g <- g[g %in% rownames(profiles)]\n      if(length(g) < 2) {\n        return(NULL)\n      }\n      \n      y_means <- Matrix::colMeans(profiles[g, , drop = FALSE])\n      single_values <- Matrix::colMeans(logcounts(sce)[g,])\n      \n      if(relative) {\n        norm_factor <- max(y_means)\n      } else {\n        norm_factor <- 1\n      }\n      \n      y_means <- y_means/norm_factor\n      single_values <- single_values/norm_factor\n      \n      days <- colnames(profiles)\n      y_sds <- sapply(days, function(d) {\n        vals <- Matrix::colMeans(logcounts(sce)[g, colData(sce)[,coldata] == d, drop = FALSE])/norm_factor\n        sd(vals)\n      })\n      y_sds[which(is.na(y_sds))] <- 0\n      \n      ylim_range <- range(c(y_means - y_sds, y_means + y_sds))\n      ylim_range_two <- range(single_values)\n      ylim_range <- c(min(c(ylim_range[1], ylim_range_two[1])), max(c(ylim_range[2], ylim_range_two[2])))\n      if(!is.null(ylim)) {\n        ylim_range <- ylim\n      }\n      \n      lines(y_means,\n           lwd = 2,\n           col = net$SubClass_color[which(net$SubClass == i)][1])\n      \n      x_vals <- seq_along(y_means)\n      upper <- y_means + y_sds\n      lower <- y_means - y_sds\n      polygon(c(x_vals, rev(x_vals)),\n              c(upper, rev(lower)),\n              col = adjustcolor(net$SubClass_color[which(net$SubClass == i)][1], alpha.f = 0.2),\n              border = NA)\n      \n      lines(x_vals, y_means, lwd = 2,\n            col = net$SubClass_color[which(net$SubClass == i)][1])\n      \n      for (j in seq_along(y_means)) {\n        d <- names(y_means)[j]\n        y_vals <- single_values[which(colData(sce)[,coldata] == d)]\n        x_jitter <- jitter(rep(j, length(y_vals)), amount = 0.1)\n        x_jitter[1] <- j\n        show_top <- length(x_jitter)-2\n        if(length(x_jitter) < 2) {\n          idxs <- seq(1,length(x_jitter))\n        } else {\n          idxs <- c(which.min(y_vals), which.max(y_vals), sample(seq(1,length(x_jitter)), show_top)) \n        }\n        x_jitter <- x_jitter[idxs]\n        y_vals <- y_vals[idxs]\n        points(x_jitter, y_vals, pch = 19, col = adjustcolor(net$SubClass_color[which(net$SubClass == i)][1], alpha.f = 0.5), cex = 0.5)\n      }\n    }\n    \n  }\n}\nplotTrends(net = corticogenesis_sce, \n           pref_exp_genes = corticogenesis_pe_genes, \n           subclass = c('Astro', 'cRG'), \n           sce = bulk_sce, \n           profiles = bulk_average, \n           coldata = 'differentiation day', \n           together = TRUE, \n           ylim = c(2.5, 5.5))\nbulk_cortico_GOBP <- do.call(rbind, lapply(corticogenesis_GO, function(g) {\n  \n  g <- g[which(g %in% rownames(bulk_sce))]\n  \n  Matrix::colMeans(bulk_average[g,])\n  \n}))\n\nrownames(bulk_cortico_GOBP) <- gsub(\" \\\\(GO:[0-9]+\\\\)$\", \"\", rownames(bulk_cortico_GOBP))\nbulk_cortico_GOBP <- bulk_cortico_GOBP[,mixedorder(colnames(bulk_cortico_GOBP))]\ncortico_subclass_groups <- colnames(corticogenesis_preferential_GO$GO_Biological_Process_2025$preferential)\ncortico_subclass_groups[which(cortico_subclass_groups %in% c('L23IT', 'L35IT', 'L6IT', 'L6NIT'))] <- 'matEN'\ncortico_subclass_groups[which(cortico_subclass_groups %in% c('LAMP5', 'SST', 'PVALB', 'VIP'))] <- 'matIN'\ncortico_subclass_groups[which(cortico_subclass_groups %in% c('imIT', 'imNIT', 'eEN', 'miEN'))] <- 'immEN'\ncortico_subclass_groups[which(cortico_subclass_groups %in% c('eIN', 'imIN'))] <- 'immIN'\ncortico_subclass_groups[which(cortico_subclass_groups %in% c('Opc', 'Oligo', 'Astro'))] <- 'maGlia'\ncortico_subclass_groups[which(cortico_subclass_groups %in% c('Micro'))] <- 'miGlia'\ncortico_subclass_groups[which(cortico_subclass_groups %in% c('RG', 'cRG', 'IPC'))] <- 'Prog'\n\ncortico_subclass_groups <- factor(cortico_subclass_groups, levels = c('Prog', 'immEN', 'immIN', 'matEN', 'matIN', 'maGlia', 'miGlia'))\n\ncortico_gobp_groups <- factor(c(rep('Astro', 4), rep('Oligo', 3), rep('Opc', 3), rep('OligoGlia', 2), rep('matEN', 4), rep('matIN', 4), rep('immEN', 4), rep('Micro', 4), rep('Prog', 4), rep('Stress', 4)), levels = c('Prog', 'immEN', 'matEN', 'matIN', 'Opc', 'Oligo', 'OligoGlia', 'Astro', 'Micro', 'Stress'))\n\ncortico_gobp_pe <- corticogenesis_preferential_GO$GO_Biological_Process_2025$preferential[names(corticogenesis_GO),]\nrownames(cortico_gobp_pe) <- gsub(\" \\\\(GO:[0-9]+\\\\)$\", \"\", rownames(cortico_gobp_pe))\nht1 <- Heatmap(\n  cortico_gobp_pe,\n  name = 'preferential\\nexpression',\n  width = unit(ncol(cortico_gobp_pe) * 4.2, 'mm'),\n  height = unit(nrow(cortico_gobp_pe) * 4.2, 'mm'),\n  show_row_dend = FALSE,\n  show_column_dend = FALSE,\n  row_title_rot = 0,\n  column_title_rot = 90,\n  column_split = cortico_subclass_groups,\n  cluster_column_slices = FALSE,\n  row_split = cortico_gobp_groups,\n  cluster_row_slices = FALSE,\n  column_title_gp = gpar(fontsize = 0)\n)\n\nht2 <- Heatmap(\n  t(scale(t(bulk_cortico_GOBP))),\n  name = 'scaled\\nexpression',\n  width = unit(ncol(bulk_cortico_GOBP) * 4.2, 'mm'),\n  cluster_columns = FALSE, right_annotation = rowAnnotation(max = anno_barplot(apply(bulk_cortico_GOBP, 1, max), gp = gpar(fill = 'black')), annotation_name_side = 'top', annotation_name_rot = 0)\n)\n\nht_list <- ht1 + ht2\n\ndraw(ht_list, heatmap_legend_side = \"left\")\nbulk_neuro_GOBP <- do.call(rbind, lapply(neurogenesis_GO, function(g) {\n  \n  g <- g[which(g %in% rownames(bulk_average))]\n  \n  Matrix::colMeans(bulk_average[g,])\n  \n}))\n\nrownames(bulk_neuro_GOBP) <- gsub(\" \\\\(GO:[0-9]+\\\\)$\", \"\", rownames(bulk_neuro_GOBP))\nbulk_neuro_GOBP <- bulk_neuro_GOBP[,mixedorder(colnames(bulk_neuro_GOBP))]\nneuro_gobp_pe <- neurogenesis_preferential_GO$GO_Biological_Process_2025$activity[names(neurogenesis_GO),]\n\nneuroTrends <- do.call(cbind, lapply(rownames(neuro_gobp_pe), function(i) smooth.spline(1:length(neuro_gobp_pe[i,]), neuro_gobp_pe[i,], spar = 1)$y))\ncolnames(neuroTrends) <- rownames(neuro_gobp_pe)\n\nneuroTrends <- t(neuroTrends)[names(neurogenesis_GO),]\nneuroTrends <- neuroTrends[order(apply(neuroTrends, 1, which.max), Matrix::rowMeans(neuroTrends)),]\n\nrownames(neuroTrends) <- gsub(\" \\\\(GO:[0-9]+\\\\)$\", \"\", rownames(neuroTrends))\n\nstage_palette <- unique(neurogenesis_sce$Stages_color)\nnames(stage_palette) <- unique(neurogenesis_sce$Stages)\n\nh1 <- Heatmap(t(scale(t(neuroTrends))), \n              cluster_columns = F, \n              cluster_rows = F, \n              bottom_annotation = HeatmapAnnotation(df=data.frame(stage=neurogenesis_sce$Stages), \n                                                    col=list(stage=stage_palette), \n                                                    show_legend = F, \n                                                    show_annotation_name = F), \n              name = 'inferred expression\\n(z scaled)', \n              height = unit(100, 'mm'), \n              width = unit(30, 'mm'), \n              row_names_max_width = unit(20, \"mm\"))\n\nht2 <- Heatmap(\n  t(scale(t(bulk_neuro_GOBP[rownames(neuroTrends),]))),\n  name = 'scaled\\nexpression',\n  width = unit(ncol(bulk_neuro_GOBP) * 4.2, 'mm'),\n  cluster_columns = FALSE, right_annotation = rowAnnotation(max = anno_barplot(apply(bulk_neuro_GOBP[rownames(neuroTrends),], 1, max), gp = gpar(fill = 'black'))), , row_names_max_width = unit(20, \"mm\")\n)\n\nht_list <- h1 + ht2\ndraw(ht_list, \n     heatmap_legend_side = \"left\")\ndge_obj <- DGEList(counts=counts(bulk_sce), \n                   samples=cbind(colData(bulk_sce), \n                                 bulk_sce$`differentiation day`))\n\nkeep <- filterByExpr(dge_obj, \n                     group=bulk_sce$`differentiation day`)\n\ndge_obj <- dge_obj[keep, , keep.lib.sizes=FALSE]\n\ndge_obj <- calcNormFactors(dge_obj)\nunique_groups <- unique(bulk_sce$`differentiation day`)\nde_list <- list()\n\nfor (g in unique_groups) {\n  binary_group <- ifelse(bulk_sce$`differentiation day` == g, g, paste0(\"Not\", g))\n  binary_group <- factor(binary_group)\n  \n  sample_info <- data.frame('binary_group' = binary_group, \n                            'groups' = bulk_sce$`differentiation day`)\n  \n  design <- stats::model.matrix(~ binary_group, data=sample_info)\n  \n  dge_obj <- estimateDisp(dge_obj, \n                          design)\n  \n  fit <- glmQLFit(dge_obj, \n                  design)\n  \n  qlf <- glmQLFTest(fit, \n                    coef=2)\n  \n  res <- topTags(qlf, \n                 n=Inf)\n  \n  res <- res$table[which(res$table$FDR < 0.05),]\n  \n  if(all(sign(res$logFC) == sign(res$logFC)[1])) {\n    de_list[[g]] <- res\n    next()\n  }\n  \n  v1 <- Matrix::colMeans(bulk_average[rownames(res)[which(res$logFC > 0)],])\n  v2 <- Matrix::colMeans(bulk_average[rownames(res)[which(res$logFC < 0)],])\n  \n  if(rank(v1)[g] > rank(v2)[g]) {\n    res <- res[which(res$logFC > 0),]  \n  } else {\n    res <- res[which(res$logFC < 0),]\n  }\n  \n  de_list[[g]] <- res\n}\nde_list <- lapply(de_list, function(i) {\n  i$score <- -log10(i$FDR)\n  i <- i[order(i$score, decreasing = T),]\n  return(i)\n  }\n)\n\nmarkers <- lapply(de_list, function(i) {\n  rownames(i)\n  }\n)\n\nmarkers <- lapply(markers, function(i) {\n  i[which(i %in% rownames(corticogenesis_sce))]\n  }\n)\n\nmarkers <- markers[which(unlist(lapply(markers, length)) > 0)]\nfor(i in names(markers)) {\n  g <- markers[[i]]\n  g <- g[which(g %in% rownames(corticogenesis_sce))]\n  plot_eTrace(net = corticogenesis_sce, genes = g, main = i)\n}"}]
